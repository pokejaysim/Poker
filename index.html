<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Texas Hold'em Poker - Live Multiplayer</title>
    <style>        <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Texas Hold'em Poker - Live Multiplayer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Mobile-specific body styles */
        @media (max-width: 768px) {
            body {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                /* Hide scrollbar on mobile */
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            
            body::-webkit-scrollbar {
                display: none;
            }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .lobby {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }

        .lobby h1 {
            font-size: 4rem;
            margin-bottom: 2rem;
            background: linear-gradient(45deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(243, 156, 18, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        .mobile-hint {
            display: none;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 20px;
            font-size: 1.1rem;
            animation: fadeIn 1s ease-in;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 20px rgba(243, 156, 18, 0.5)); }
            to { filter: drop-shadow(0 0 30px rgba(231, 76, 60, 0.8)); }
        }

        .lobby-actions {
            display: flex;
            gap: 20px;
            margin-bottom: 2rem;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.2rem;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        .btn-primary {
            background: linear-gradient(45deg, #e74c3c, #f39c12);
            color: white;
            box-shadow: 0 5px 20px rgba(231, 76, 60, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(231, 76, 60, 0.6);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group input {
            padding: 15px 25px;
            font-size: 1.1rem;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            width: 300px;
        }

        .input-group input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .input-group input:focus {
            outline: none;
            border-color: #f39c12;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.3);
        }

        .game-table {
            display: none;
            position: relative;
            background: radial-gradient(ellipse at center, #2d4a2b 0%, #1a2f19 100%);
            border-radius: 200px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), inset 0 0 100px rgba(0, 0, 0, 0.5);
            margin: 20px auto;
            max-width: 1000px;
            border: 10px solid #3e2723;
        }

        .community-cards {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 40px 0;
            min-height: 120px;
        }

        .card {
            width: 80px;
            height: 110px;
            border-radius: 10px;
            background: linear-gradient(135deg, #fff 0%, #f0f0f0 100%);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            animation: dealCard 0.5s ease-out;
        }

        @keyframes dealCard {
            from {
                transform: translateY(-50px) rotateY(180deg) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translateY(0) rotateY(0) scale(1);
                opacity: 1;
            }
        }

        .card.red { color: #e74c3c; }
        .card.black { color: #2c3e50; }

        .card.back {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: transparent;
        }

        .card.back::before {
            content: 'â™ ';
            position: absolute;
            font-size: 3rem;
            color: rgba(255, 255, 255, 0.1);
            transform: rotate(45deg);
        }

        .players-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 40px;
        }

        .player-slot {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            min-width: 200px;
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
        }

        .position-indicator {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #f39c12;
            color: #000;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .position-indicator.dealer {
            background: #f39c12;
            font-size: 0.75rem;
            letter-spacing: -0.5px;
        }

        .position-indicator.small-blind {
            background: #3498db;
            width: 30px;
            height: 30px;
            font-size: 0.8rem;
        }

        .position-indicator.big-blind {
            background: #e74c3c;
            width: 30px;
            height: 30px;
            font-size: 0.8rem;
        }

        .player-slot.active {
            border-color: #f39c12;
            box-shadow: 0 0 30px rgba(243, 156, 18, 0.5);
        }

        .player-slot.current-player {
            background: rgba(243, 156, 18, 0.2);
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #f39c12;
        }

        .player-chips {
            font-size: 1.1rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .player-hand-rank {
            font-size: 0.9rem;
            color: #3498db;
            margin-bottom: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 5px 10px;
            background: rgba(52, 152, 219, 0.2);
            border-radius: 20px;
            display: inline-block;
            animation: fadeIn 0.3s ease-in;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .player-hand-rank.strong {
            color: #2ecc71;
            background: rgba(46, 204, 113, 0.2);
        }

        .player-hand-rank.very-strong {
            color: #e74c3c;
            background: rgba(231, 76, 60, 0.2);
            animation: glow 1s ease-in-out infinite alternate;
        }

        .chip-icon {
            width: 20px;
            height: 20px;
            background: #f39c12;
            border-radius: 50%;
            display: inline-block;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
        }

        .player-cards {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            min-height: 110px;
        }

        .pot-info {
            text-align: center;
            margin: 30px 0;
            font-size: 1.8rem;
            font-weight: bold;
            color: #f39c12;
            text-shadow: 0 0 20px rgba(243, 156, 18, 0.5);
        }

        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .action-btn {
            padding: 12px 30px;
            font-size: 1rem;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .btn-fold {
            background: #e74c3c;
            color: white;
        }

        .btn-call {
            background: #3498db;
            color: white;
        }

        .btn-raise {
            background: #2ecc71;
            color: white;
        }

        .btn-check {
            background: #95a5a6;
            color: white;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .bet-input {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        .bet-input input {
            padding: 10px 20px;
            font-size: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            width: 150px;
        }

        .game-status {
            text-align: center;
            font-size: 1.2rem;
            margin: 20px 0;
            color: #ecf0f1;
            min-height: 30px;
        }

        .winner-announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            z-index: 1000;
            animation: winnerPop 0.5s ease-out;
            backdrop-filter: blur(10px);
            border: 3px solid #f39c12;
            box-shadow: 0 0 50px rgba(243, 156, 18, 0.5);
        }

        @keyframes winnerPop {
            from {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .winner-announcement h2 {
            font-size: 3rem;
            color: #f39c12;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(243, 156, 18, 0.8);
        }

        .winner-announcement p {
            font-size: 1.5rem;
            margin-bottom: 20px;
        }

        .winner-announcement .btn {
            margin: 10px;
        }

        .room-code {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 1.2rem;
            letter-spacing: 2px;
            margin: 20px 0;
            display: inline-block;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #f39c12;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .login-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }

        .login-container h1 {
            font-size: 4rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(243, 156, 18, 0.5);
        }

        .login-container p {
            font-size: 1.2rem;
            margin-bottom: 3rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .divider {
            display: flex;
            align-items: center;
            margin: 30px auto;
            width: 100%;
            max-width: 400px;
        }

        .divider::before,
        .divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255, 255, 255, 0.2);
        }

        .divider span {
            padding: 0 20px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
        }

        .google-signin-btn {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 30px;
            background: white;
            color: #333;
            border: none;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .google-signin-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
        }

        .google-icon {
            width: 24px;
            height: 24px;
        }

        .user-info {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #f39c12;
        }

        .user-name {
            font-weight: 600;
            color: #f39c12;
        }

        .user-name.guest {
            font-style: italic;
            opacity: 0.9;
        }

        .sign-out-btn {
            padding: 8px 16px;
            background: rgba(231, 76, 60, 0.8);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .sign-out-btn:hover {
            background: rgba(231, 76, 60, 1);
        }

        .hand-guide {
            margin-top: 20px;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
        }

        .hand-guide summary {
            cursor: pointer;
            color: #f39c12;
            font-weight: 600;
            padding: 10px;
            background: rgba(243, 156, 18, 0.1);
            border-radius: 20px;
            display: inline-block;
            transition: all 0.3s ease;
        }

        .hand-guide summary:hover {
            background: rgba(243, 156, 18, 0.2);
        }

        .hand-guide div {
            margin-top: 10px;
            text-align: left;
            max-width: 400px;
            margin: 10px auto;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .hand-guide div > div {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .hand-guide div > div:last-child {
            border-bottom: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .lobby h1, .login-container h1 {
                font-size: 2.5rem;
            }
            
            .lobby-actions {
                flex-direction: column;
                width: 100%;
                max-width: 300px;
            }
            
            .btn {
                width: 100%;
                padding: 18px 30px;
                font-size: 1.1rem;
            }
            
            .input-group input {
                width: 100%;
                max-width: 300px;
            }
            
            .user-info {
                position: fixed !important;
                top: 10px;
                right: 10px;
                padding: 8px 15px;
                flex-direction: row;
                gap: 10px;
            }
            
            .user-avatar {
                width: 30px;
                height: 30px;
            }
            
            .user-name {
                display: none;
            }
            
            .sign-out-btn {
                padding: 6px 12px;
                font-size: 0.8rem;
            }
            
            .game-table {
                padding: 15px;
                border-radius: 20px;
                margin: 10px;
                border-width: 5px;
            }
            
            .room-code {
                font-size: 1rem;
                padding: 8px 15px;
                margin: 10px 0;
            }
            
            .players-container {
                flex-direction: column;
                gap: 15px;
                margin-bottom: 20px;
            }
            
            .player-slot {
                width: 100%;
                padding: 15px;
                min-width: unset;
            }
            
            .player-name {
                font-size: 1.1rem;
                margin-bottom: 8px;
            }
            
            .player-chips {
                font-size: 1rem;
                margin-bottom: 8px;
            }
            
            .player-hand-rank {
                font-size: 0.85rem;
                padding: 4px 8px;
                margin-bottom: 8px;
            }
            
            .player-cards {
                display: flex;
                gap: 5px;
                justify-content: center;
                min-height: 85px;
            }
            
            .community-cards {
                gap: 8px;
                margin: 20px 0;
                min-height: 85px;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .card {
                width: 50px;
                height: 70px;
                font-size: 1.2rem;
                border-radius: 8px;
            }
            
            .card.back::before {
                font-size: 2rem;
            }
            
            .position-indicator {
                width: 25px;
                height: 25px;
                font-size: 0.7rem;
                top: -8px;
                right: -8px;
            }
            
            .pot-info {
                font-size: 1.4rem;
                margin: 20px 0;
            }
            
            .pot-info div {
                font-size: 0.7rem;
                margin-top: 3px;
            }
            
            .game-status {
                font-size: 1rem;
                margin: 15px 0;
                padding: 0 10px;
                text-align: center;
            }
            
            .hand-guide {
                margin-top: 15px;
            }
            
            .hand-guide summary {
                font-size: 0.85rem;
                padding: 8px 15px;
            }
            
            .hand-guide div {
                font-size: 0.8rem;
                padding: 10px;
            }
            
            .action-buttons {
                gap: 10px;
                margin-top: 20px;
                position: fixed;
                bottom: 20px;
                left: 10px;
                right: 10px;
                background: rgba(0, 0, 0, 0.8);
                padding: 15px;
                border-radius: 20px;
                backdrop-filter: blur(10px);
                z-index: 100;
            }
            
            .action-btn {
                padding: 15px 20px;
                font-size: 0.95rem;
                min-width: 80px;
                flex: 1;
            }
            
            .bet-input {
                position: fixed;
                bottom: 100px;
                left: 10px;
                right: 10px;
                background: rgba(0, 0, 0, 0.9);
                padding: 15px;
                border-radius: 20px;
                backdrop-filter: blur(10px);
                z-index: 101;
                gap: 10px;
            }
            
            .bet-input input {
                flex: 1;
                padding: 12px 20px;
                font-size: 1rem;
            }
            
            .bet-input .btn-raise {
                flex: 0 0 auto;
            }
            
            .winner-announcement {
                padding: 30px;
                width: 90%;
                max-width: 350px;
            }
            
            .winner-announcement h2 {
                font-size: 2rem;
            }
            
            .winner-announcement p {
                font-size: 1.2rem;
            }
            
            .winner-announcement .btn {
                width: 100%;
                margin: 5px 0;
            }
            
            /* Add padding to bottom to account for fixed action buttons */
            .game-table {
                padding-bottom: 100px;
            }
        }

        /* Tablet specific adjustments */
        @media (min-width: 769px) and (max-width: 1024px) {
            .game-table {
                max-width: 800px;
                padding: 30px;
            }
            
            .card {
                width: 70px;
                height: 95px;
                font-size: 1.7rem;
            }
            
            .player-slot {
                min-width: 180px;
                padding: 18px;
            }
        }

        /* Large desktop enhancements */
        @media (min-width: 1400px) {
            .container {
                max-width: 1600px;
            }
            
            .game-table {
                max-width: 1200px;
                padding: 50px;
            }
            
            .card {
                width: 90px;
                height: 125px;
                font-size: 2.5rem;
            }
            
            .player-slot {
                min-width: 250px;
                padding: 25px;
            }
            
            .player-name {
                font-size: 1.4rem;
            }
            
            .pot-info {
                font-size: 2rem;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .btn:active, .action-btn:active {
                transform: scale(0.95);
            }
            
            .card {
                /* Prevent text selection on cards */
                -webkit-user-select: none;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
            }
        }

        /* Landscape mode on mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .container {
                padding: 5px;
            }
            
            .game-table {
                padding: 10px;
                margin: 5px;
            }
            
            .players-container {
                flex-direction: row;
                gap: 10px;
            }
            
            .player-slot {
                padding: 10px;
                width: 48%;
            }
            
            .card {
                width: 45px;
                height: 65px;
                font-size: 1.1rem;
            }
            
            .action-buttons {
                bottom: 10px;
                padding: 10px;
            }
            
            .action-btn {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .game-table {
                padding-bottom: 80px;
            }
            
            .pot-info {
                font-size: 1.2rem;
                margin: 15px 0;
            }
            
            .hand-guide {
                display: none;
            }
        }

        /* Notch/Safe area support for modern phones */
        @supports (padding: max(0px)) {
            .container {
                padding-left: max(20px, env(safe-area-inset-left));
                padding-right: max(20px, env(safe-area-inset-right));
            }
            
            @media (max-width: 768px) {
                .action-buttons {
                    bottom: max(20px, env(safe-area-inset-bottom));
                    left: max(10px, env(safe-area-inset-left));
                    right: max(10px, env(safe-area-inset-right));
                }
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="login-container" id="loginScreen">
            <h1>Texas Hold'em Poker</h1>
            <p>Sign in to start playing</p>
            <button class="google-signin-btn" onclick="signInWithGoogle()">
                <svg class="google-icon" viewBox="0 0 24 24">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Sign in with Google
            </button>
            <div class="divider"><span>or</span></div>
            <button class="btn btn-secondary" onclick="signInAnonymously()">
                Play as Guest
            </button>
        </div>

        <div class="lobby" id="lobby" style="display: none;">
            <div class="user-info" id="userInfo">
                <img class="user-avatar" id="userAvatar" src="" alt="Avatar" onerror="this.src='https://www.gravatar.com/avatar/?d=mp&s=200'">
                <span class="user-name" id="userName"></span>
                <button class="sign-out-btn" onclick="signOut()">Sign Out</button>
            </div>
            <h1>Texas Hold'em Poker</h1>
            <p class="mobile-hint" style="display: none; color: rgba(255, 255, 255, 0.7); margin-bottom: 20px;">Swipe or tap to play!</p>
            <div class="lobby-actions">
                <button class="btn btn-primary" onclick="createGame()">Create Game</button>
                <button class="btn btn-secondary" onclick="showJoinGame()">Join Game</button>
            </div>
            <div id="joinGameSection" style="display: none;">
                <div class="input-group">
                    <input type="text" id="roomCode" placeholder="Enter room code" maxlength="6" autocomplete="off" autocorrect="off" autocapitalize="off">
                </div>
                <button class="btn btn-primary" onclick="joinGame()">Join</button>
            </div>
        </div>

        <div class="game-table" id="gameTable" style="display: none;">
            <div class="user-info" style="position: relative; margin-bottom: 20px;">
                <img class="user-avatar" id="gameUserAvatar" src="" alt="Avatar" onerror="this.src='https://www.gravatar.com/avatar/?d=mp&s=200'">
                <span class="user-name" id="gameUserName"></span>
                <button class="sign-out-btn" onclick="leaveGame()">Leave Game</button>
            </div>
            <div class="room-code" id="roomCodeDisplay"></div>
            
            <div class="players-container">
                <div class="player-slot" id="player1">
                    <div class="position-indicator" style="display: none;"></div>
                    <div class="player-name">Waiting for player...</div>
                    <div class="player-chips"></div>
                    <div class="player-hand-rank" style="display: none;"></div>
                    <div class="player-cards"></div>
                </div>
                <div class="player-slot" id="player2">
                    <div class="position-indicator" style="display: none;"></div>
                    <div class="player-name">Waiting for player...</div>
                    <div class="player-chips"></div>
                    <div class="player-hand-rank" style="display: none;"></div>
                    <div class="player-cards"></div>
                </div>
            </div>

            <div class="pot-info">
                Pot: <span class="chip-icon"></span> <span id="potAmount">0</span>
                <div style="font-size: 0.8rem; margin-top: 5px; color: rgba(255, 255, 255, 0.7);">
                    Blinds: <span id="blindsInfo">25/50</span> â€¢ Hand #<span id="handCount">1</span>
                    <span style="display: block; font-size: 0.7rem; margin-top: 3px;">
                        (Blinds double every 5 hands)
                    </span>
                </div>
            </div>
            
            <div class="community-cards" id="communityCards"></div>
            
            <div class="game-status" id="gameStatus">Waiting for players...</div>
            
            <div class="hand-guide">
                <details>
                    <summary>Poker Hand Rankings â–¼</summary>
                    <div>
                        <div>ðŸ”´ <strong>Royal Flush</strong> - A, K, Q, J, 10 (same suit)</div>
                        <div>ðŸŸ  <strong>Straight Flush</strong> - 5 cards in sequence (same suit)</div>
                        <div>ðŸŸ¡ <strong>Four of a Kind</strong> - 4 cards of same rank</div>
                        <div>ðŸŸ¢ <strong>Full House</strong> - 3 of a kind + pair</div>
                        <div>ðŸ”µ <strong>Flush</strong> - 5 cards of same suit</div>
                        <div>ðŸŸ£ <strong>Straight</strong> - 5 cards in sequence</div>
                        <div>âš« <strong>Three of a Kind</strong> - 3 cards of same rank</div>
                        <div>âšª <strong>Two Pair</strong> - 2 pairs</div>
                        <div>ðŸ”˜ <strong>Pair</strong> - 2 cards of same rank</div>
                        <div>â­• <strong>High Card</strong> - Highest card wins</div>
                    </div>
                </details>
            </div>
            
            <div class="action-buttons" id="actionButtons" style="display: none;">
                <button class="action-btn btn-fold" onclick="playerAction('fold')">Fold</button>
                <button class="action-btn btn-check" onclick="playerAction('check')">Check</button>
                <button class="action-btn btn-call" onclick="playerAction('call')">Call</button>
                <button class="action-btn btn-raise" onclick="showRaiseInput()">Raise</button>
            </div>
            
            <div class="bet-input" id="betInput" style="display: none;">
                <input type="number" id="raiseAmount" min="1" placeholder="Amount" inputmode="numeric" pattern="[0-9]*">
                <button class="action-btn btn-raise" onclick="playerAction('raise')">Confirm Raise</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.7.1/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.7.1/firebase-firestore-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.7.1/firebase-auth-compat.min.js"></script>
    
    <script>
        // Detect mobile device
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   window.innerWidth <= 768 ||
                   ('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0);
        }
        
        let isMobile = isMobileDevice();
        
        // Update mobile detection on resize
        window.addEventListener('resize', () => {
            isMobile = isMobileDevice();
        });
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDNnyiWr2HIHsvL69LboLoUCIzVmvfanW8",
            authDomain: "poker-7eeef.firebaseapp.com",
            projectId: "poker-7eeef",
            storageBucket: "poker-7eeef.firebasestorage.app",
            messagingSenderId: "203143203913",
            appId: "1:203143203913:web:ea195b6158c16c61280398"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();

        // Game state
        let currentGame = null;
        let playerId = null;
        let playerName = null;
        let playerPhotoURL = null;
        let gameListener = null;

        // Auth state observer
        auth.onAuthStateChanged((user) => {
            if (user) {
                // User is signed in
                playerId = user.uid;
                
                // Handle anonymous users
                if (user.isAnonymous) {
                    const guestNames = ['Ace', 'King', 'Queen', 'Jack', 'Royal', 'Flush', 'Bluff', 'Shark', 'Pro'];
                    const randomName = guestNames[Math.floor(Math.random() * guestNames.length)];
                    playerName = randomName + '_' + user.uid.substring(0, 4).toUpperCase();
                    playerPhotoURL = 'https://www.gravatar.com/avatar/?d=identicon&s=200';
                } else {
                    playerName = user.displayName;
                    playerPhotoURL = user.photoURL;
                }
                
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('lobby').style.display = 'flex';
                document.getElementById('userName').textContent = playerName;
                document.getElementById('userName').className = 'user-name' + (user.isAnonymous ? ' guest' : '');
                document.getElementById('userAvatar').src = playerPhotoURL;
            } else {
                // User is signed out
                document.getElementById('loginScreen').style.display = 'flex';
                document.getElementById('lobby').style.display = 'none';
                document.getElementById('gameTable').style.display = 'none';
                
                // Clean up any active game listeners
                if (gameListener) {
                    gameListener();
                    gameListener = null;
                }
            }
        });

        // Sign in with Google
        async function signInWithGoogle() {
            const provider = new firebase.auth.GoogleAuthProvider();
            try {
                await auth.signInWithPopup(provider);
            } catch (error) {
                console.error('Error signing in:', error);
                alert('Error signing in. Please try again.');
            }
        }

        // Sign in anonymously
        async function signInAnonymously() {
            try {
                await auth.signInAnonymously();
            } catch (error) {
                console.error('Error signing in anonymously:', error);
                alert('Error signing in as guest. Please try again.');
            }
        }

        // Sign out
        async function signOut() {
            try {
                await auth.signOut();
                currentGame = null;
                playerId = null;
                playerName = null;
            } catch (error) {
                console.error('Error signing out:', error);
            }
        }

        // Card deck
        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const suitColors = { 'â™ ': 'black', 'â™£': 'black', 'â™¥': 'red', 'â™¦': 'red' };

        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function createDeck() {
            const deck = [];
            for (const suit of suits) {
                for (const rank of ranks) {
                    deck.push({ suit, rank });
                }
            }
            return shuffleDeck(deck);
        }

        function shuffleDeck(deck) {
            const newDeck = [...deck];
            for (let i = newDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
            }
            return newDeck;
        }

        async function createGame() {
            if (!auth.currentUser) {
                alert('Please sign in first');
                return;
            }

            const roomCode = generateRoomCode();
            
            const gameData = {
                roomCode,
                players: [{
                    id: playerId,
                    name: playerName,
                    chips: 5000,
                    cards: [],
                    bet: 0,
                    folded: false
                }],
                deck: createDeck(),
                communityCards: [],
                pot: 0,
                currentPlayer: 0,
                dealerPosition: 0,
                stage: 'waiting', // waiting, preflop, flop, turn, river, showdown
                currentBet: 0,
                playersActed: [],
                lastWinner: null,
                handCount: 0,
                smallBlind: 25,
                bigBlind: 50,
                created: firebase.firestore.FieldValue.serverTimestamp()
            };

            try {
                await db.collection('games').doc(roomCode).set(gameData);
                startGameListener(roomCode);
                showGame(roomCode);
            } catch (error) {
                console.error('Error creating game:', error);
                alert('Error creating game. Please try again.');
            }
        }

        function showJoinGame() {
            document.getElementById('joinGameSection').style.display = 'block';
        }

        async function joinGame() {
            if (!auth.currentUser) {
                alert('Please sign in first');
                return;
            }
            
            const roomCode = document.getElementById('roomCode').value.trim().toUpperCase();
            
            if (!roomCode) {
                alert('Please enter a room code');
                return;
            }

            try {
                const gameRef = db.collection('games').doc(roomCode);
                const gameDoc = await gameRef.get();
                
                if (!gameDoc.exists) {
                    alert('Game not found');
                    return;
                }

                const gameData = gameDoc.data();
                
                if (gameData.players.length >= 2) {
                    alert('Game is full');
                    return;
                }

                gameData.players.push({
                    id: playerId,
                    name: playerName,
                    chips: 5000,
                    cards: [],
                    bet: 0,
                    folded: false
                });

                if (gameData.players.length === 2) {
                    gameData.stage = 'preflop';
                    gameData.currentPlayer = 0; // First player starts
                    gameData.playersActed = [];
                    gameData.currentBet = 0;
                    gameData.pot = 0;
                    gameData.handCount = 0;
                    gameData.smallBlind = gameData.smallBlind || 25;
                    gameData.bigBlind = gameData.bigBlind || 50;
                    dealCards(gameData);
                }

                await gameRef.update(gameData);
                startGameListener(roomCode);
                showGame(roomCode);
            } catch (error) {
                console.error('Error joining game:', error);
                alert('Error joining game. Please try again.');
            }
        }

        function dealCards(gameData) {
            // Increment hand count
            gameData.handCount = (gameData.handCount || 0) + 1;
            
            // Check if we need to increase blinds (every 5 hands)
            if (gameData.handCount > 1 && (gameData.handCount - 1) % 5 === 0) {
                gameData.smallBlind *= 2;
                gameData.bigBlind *= 2;
            }
            
            // Deal 2 cards to each player
            for (let i = 0; i < gameData.players.length; i++) {
                gameData.players[i].cards = [
                    gameData.deck.pop(),
                    gameData.deck.pop()
                ];
                gameData.players[i].bet = 0;
                gameData.players[i].folded = false;
            }
            
            // Post blinds (for 2 players: player 0 is small blind/dealer, player 1 is big blind)
            const smallBlindPlayer = gameData.players[0];
            const bigBlindPlayer = gameData.players[1];
            
            // Post small blind (all-in if necessary)
            const smallBlindAmount = Math.min(gameData.smallBlind, smallBlindPlayer.chips);
            smallBlindPlayer.chips -= smallBlindAmount;
            smallBlindPlayer.bet = smallBlindAmount;
            gameData.pot = smallBlindAmount;
            
            // Post big blind (all-in if necessary)
            const bigBlindAmount = Math.min(gameData.bigBlind, bigBlindPlayer.chips);
            bigBlindPlayer.chips -= bigBlindAmount;
            bigBlindPlayer.bet = bigBlindAmount;
            gameData.pot += bigBlindAmount;
            
            // Set current bet to the highest bet (in case someone went all-in)
            gameData.currentBet = Math.max(smallBlindAmount, bigBlindAmount);
            
            // In heads-up (2 players), small blind acts first pre-flop
            gameData.currentPlayer = 0;
            gameData.playersActed = [];
            
            // If big blind is all-in with less than the full blind, small blind only needs to match
            if (bigBlindAmount < gameData.bigBlind && smallBlindAmount < bigBlindAmount) {
                gameData.currentBet = bigBlindAmount;
            }
        }

        function startGameListener(roomCode) {
            if (gameListener) {
                gameListener();
            }

            gameListener = db.collection('games').doc(roomCode)
                .onSnapshot((doc) => {
                    if (doc.exists) {
                        currentGame = doc.data();
                        currentGame.id = roomCode;
                        updateGameUI();
                    }
                });
        }

        function showGame(roomCode) {
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('gameTable').style.display = 'block';
            document.getElementById('roomCodeDisplay').textContent = `Room: ${roomCode}`;
            document.getElementById('gameUserName').textContent = playerName;
            document.getElementById('gameUserName').className = 'user-name' + (auth.currentUser && auth.currentUser.isAnonymous ? ' guest' : '');
            document.getElementById('gameUserAvatar').src = playerPhotoURL;
        }

        async function leaveGame() {
            if (gameListener) {
                gameListener();
                gameListener = null;
            }
            
            // Clean up any winner announcements
            const announcement = document.querySelector('.winner-announcement');
            if (announcement) {
                announcement.remove();
            }
            
            // TODO: Optionally remove player from game in Firestore
            
            currentGame = null;
            document.getElementById('gameTable').style.display = 'none';
            document.getElementById('lobby').style.display = 'flex';
            document.getElementById('joinGameSection').style.display = 'none';
            document.getElementById('roomCode').value = '';
        }

        function updateGameUI() {
            if (!currentGame) return;

            // Update players
            currentGame.players.forEach((player, index) => {
                const playerSlot = document.getElementById(`player${index + 1}`);
                const isCurrentPlayer = index === currentGame.currentPlayer;
                const isMe = player.id === playerId;
                
                playerSlot.classList.toggle('current-player', isCurrentPlayer && currentGame.stage !== 'waiting');
                playerSlot.classList.toggle('active', isMe);
                playerSlot.style.opacity = player.folded ? '0.5' : '1';
                
                // Update position indicators (dealer/blinds)
                const positionEl = playerSlot.querySelector('.position-indicator');
                if (currentGame.stage !== 'waiting' && currentGame.players.length === 2) {
                    // In heads-up, player 0 is dealer/small blind, player 1 is big blind
                    if (index === 0) {
                        positionEl.style.display = 'flex';
                        positionEl.className = 'position-indicator dealer';
                        positionEl.innerHTML = 'D/SB';
                        positionEl.title = 'Dealer / Small Blind';
                    } else if (index === 1) {
                        positionEl.style.display = 'flex';
                        positionEl.className = 'position-indicator big-blind';
                        positionEl.innerHTML = 'BB';
                        positionEl.title = 'Big Blind';
                    }
                } else {
                    positionEl.style.display = 'none';
                }
                
                playerSlot.querySelector('.player-name').textContent = player.name + (isMe ? ' (You)' : '') + (player.folded ? ' (Folded)' : '');
                
                const chipsEl = playerSlot.querySelector('.player-chips');
                if (player.chips === 0) {
                    chipsEl.innerHTML = `<span class="chip-icon"></span> <span style="color: #e74c3c; font-weight: bold;">BANKRUPT</span>`;
                } else {
                    chipsEl.innerHTML = `<span class="chip-icon"></span> ${player.chips}` + 
                        (player.bet > 0 ? ` (Bet: ${player.bet})` : '');
                }
                
                // Update hand rank display
                const handRankEl = playerSlot.querySelector('.player-hand-rank');
                if (player.cards && player.cards.length > 0 && !player.folded && player.chips > 0) {
                    // Show hand rank for yourself always, and for all players during showdown
                    if (isMe || currentGame.stage === 'showdown') {
                        let handEval;
                        
                        if (currentGame.communityCards.length === 0) {
                            // Pre-flop: evaluate hole cards only
                            handEval = evaluateHoleCards(player.cards);
                        } else {
                            // Post-flop: evaluate best 5-card hand
                            const allCards = [...player.cards, ...currentGame.communityCards];
                            handEval = evaluateHand(allCards);
                        }
                        
                        handRankEl.textContent = handEval.name;
                        handRankEl.style.display = 'inline-block';
                        
                        // Add styling based on hand strength
                        handRankEl.className = 'player-hand-rank';
                        if (handEval.rank >= 6) {
                            handRankEl.classList.add('very-strong');
                        } else if (handEval.rank >= 3) {
                            handRankEl.classList.add('strong');
                        }
                    } else {
                        handRankEl.style.display = 'none';
                    }
                } else {
                    handRankEl.style.display = 'none';
                }
                
                const cardsContainer = playerSlot.querySelector('.player-cards');
                cardsContainer.innerHTML = '';
                
                if (player.cards && player.cards.length > 0) {
                    player.cards.forEach(card => {
                        const cardEl = document.createElement('div');
                        cardEl.className = `card ${isMe || currentGame.stage === 'showdown' ? suitColors[card.suit] : 'back'}`;
                        cardEl.textContent = isMe || currentGame.stage === 'showdown' ? `${card.rank}${card.suit}` : '';
                        cardsContainer.appendChild(cardEl);
                    });
                }
            });

            // Update pot
            document.getElementById('potAmount').textContent = currentGame.pot;
            
            // Update blinds info
            if (currentGame.smallBlind && currentGame.bigBlind) {
                document.getElementById('blindsInfo').textContent = `${currentGame.smallBlind}/${currentGame.bigBlind}`;
            }
            
            // Update hand count
            if (currentGame.handCount) {
                document.getElementById('handCount').textContent = currentGame.handCount;
            }

            // Update community cards
            const communityContainer = document.getElementById('communityCards');
            communityContainer.innerHTML = '';
            
            currentGame.communityCards.forEach(card => {
                const cardEl = document.createElement('div');
                cardEl.className = `card ${suitColors[card.suit]}`;
                cardEl.textContent = `${card.rank}${card.suit}`;
                communityContainer.appendChild(cardEl);
            });

            // Update game status
            updateGameStatus();

            // Update action buttons
            updateActionButtons();
            
            // Auto-continue after showdown (unless game is over)
            if (currentGame.stage === 'showdown' && currentGame.lastWinner && !currentGame.players.some(p => p.chips === 0)) {
                // Already handled in determineWinner/checkForBankruptcy
            }
        }

        function updateGameStatus() {
            const statusEl = document.getElementById('gameStatus');
            
            if (currentGame.stage === 'waiting') {
                statusEl.textContent = 'Waiting for another player...';
            } else if (currentGame.stage === 'gameover') {
                statusEl.innerHTML = '<strong style="color: #e74c3c;">Game Over!</strong>';
            } else if (currentGame.stage === 'showdown') {
                // Show who won during showdown
                if (currentGame.lastWinner) {
                    statusEl.innerHTML = `<strong style="color: #f39c12;">${currentGame.lastWinner.name} wins ${currentGame.lastWinner.amount} chips with ${currentGame.lastWinner.hand}!</strong>`;
                } else {
                    statusEl.textContent = 'Showdown!';
                }
            } else {
                const currentPlayer = currentGame.players[currentGame.currentPlayer];
                const isMyTurn = currentPlayer.id === playerId;
                
                // Vibrate on mobile when it's your turn (if supported)
                if (isMyTurn && isMobile && 'vibrate' in navigator && !statusEl.dataset.vibrated) {
                    navigator.vibrate(200);
                    statusEl.dataset.vibrated = 'true';
                } else if (!isMyTurn) {
                    delete statusEl.dataset.vibrated;
                }
                
                // Show current stage
                const stageNames = {
                    'preflop': 'Pre-Flop',
                    'flop': 'Flop',
                    'turn': 'Turn',
                    'river': 'River'
                };
                
                const stageName = stageNames[currentGame.stage] || currentGame.stage;
                
                if (isMyTurn) {
                    statusEl.innerHTML = `<strong>${stageName}</strong> - ${isMobile ? 'ðŸ‘† ' : ''}Your turn to act`;
                } else {
                    statusEl.innerHTML = `<strong>${stageName}</strong> - Waiting for ${currentPlayer.name}...`;
                }
                
                // Show current bet if any
                if (currentGame.currentBet > 0) {
                    statusEl.innerHTML += ` (Current bet: ${currentGame.currentBet})`;
                }
                
                // Show blind increase warning
                if (currentGame.handCount && currentGame.handCount % 5 === 4) {
                    statusEl.innerHTML += '<br><small style="color: #e74c3c;">âš ï¸ Blinds will increase next hand!</small>';
                }
                
                // Show last winner info if this is a new hand
                if (currentGame.lastWinner && currentGame.stage === 'preflop' && (!currentGame.communityCards || currentGame.communityCards.length === 0)) {
                    statusEl.innerHTML = `<small style="color: #f39c12;">Last hand: ${currentGame.lastWinner.name} won ${currentGame.lastWinner.amount} chips</small><br>` + statusEl.innerHTML;
                }
            }
        }

        function updateActionButtons() {
            const actionButtons = document.getElementById('actionButtons');
            const betInput = document.getElementById('betInput');
            
            if (!currentGame || !currentGame.players) return;
            
            const currentPlayer = currentGame.players[currentGame.currentPlayer];
            const isMyTurn = currentPlayer && currentPlayer.id === playerId;
            const myPlayer = currentGame.players.find(p => p.id === playerId);
            
            if (isMyTurn && currentGame.stage !== 'waiting' && currentGame.stage !== 'showdown' && currentGame.stage !== 'gameover' && !myPlayer.folded) {
                actionButtons.style.display = 'flex';
                
                // Update button states
                const checkBtn = actionButtons.querySelector('.btn-check');
                const callBtn = actionButtons.querySelector('.btn-call');
                const raiseBtn = actionButtons.querySelector('.btn-raise');
                
                const callAmount = currentGame.currentBet - myPlayer.bet;
                
                if (callAmount === 0) {
                    checkBtn.style.display = 'block';
                    callBtn.style.display = 'none';
                } else {
                    checkBtn.style.display = 'none';
                    callBtn.style.display = 'block';
                    
                    // Handle all-in situations
                    if (callAmount >= myPlayer.chips) {
                        callBtn.textContent = `All-in ${myPlayer.chips}`;
                    } else {
                        callBtn.textContent = `Call ${callAmount}`;
                    }
                }
                
                // Disable raise if player doesn't have enough chips
                if (myPlayer.chips <= callAmount) {
                    raiseBtn.disabled = true;
                } else {
                    raiseBtn.disabled = false;
                }
            } else {
                actionButtons.style.display = 'none';
                betInput.style.display = 'none';
            }
        }

        function showRaiseInput() {
            document.getElementById('betInput').style.display = 'flex';
            const myPlayer = currentGame.players.find(p => p.id === playerId);
            const callAmount = currentGame.currentBet - myPlayer.bet;
            
            // Minimum raise must be at least the size of the big blind or the last raise amount
            const minRaiseAmount = currentGame.bigBlind;
            const minRaise = callAmount + minRaiseAmount;
            const maxRaise = myPlayer.chips - callAmount;
            
            const raiseInput = document.getElementById('raiseAmount');
            raiseInput.min = minRaise;
            raiseInput.max = maxRaise;
            raiseInput.value = minRaise;
            raiseInput.placeholder = `Min: ${minRaise}, Max: ${maxRaise}`;
            
            // Auto-focus on mobile
            if (isMobile) {
                setTimeout(() => {
                    raiseInput.focus();
                    raiseInput.select();
                }, 100);
            }
        }

        async function playerAction(action) {
            // Prevent actions during showdown or game over
            if (currentGame.stage === 'showdown' || currentGame.stage === 'gameover') {
                return;
            }
            
            const myPlayerIndex = currentGame.players.findIndex(p => p.id === playerId);
            const myPlayer = currentGame.players[myPlayerIndex];
            const gameRef = db.collection('games').doc(currentGame.id);
            
            try {
                const updates = {
                    players: currentGame.players,
                    pot: currentGame.pot,
                    currentBet: currentGame.currentBet,
                    currentPlayer: currentGame.currentPlayer,
                    stage: currentGame.stage,
                    communityCards: currentGame.communityCards,
                    deck: currentGame.deck,
                    playersActed: currentGame.playersActed || []
                };

                switch (action) {
                    case 'fold':
                        myPlayer.folded = true;
                        // When folding, we still count as having acted
                        if (!updates.playersActed.includes(myPlayerIndex)) {
                            updates.playersActed.push(myPlayerIndex);
                        }
                        break;
                        
                    case 'check':
                        // No action needed for chips
                        break;
                        
                    case 'call':
                        const callAmount = currentGame.currentBet - myPlayer.bet;
                        const actualCallAmount = Math.min(callAmount, myPlayer.chips);
                        
                        myPlayer.chips -= actualCallAmount;
                        myPlayer.bet += actualCallAmount;
                        updates.pot += actualCallAmount;
                        break;
                        
                    case 'raise':
                        const raiseAmount = parseInt(document.getElementById('raiseAmount').value);
                        if (isNaN(raiseAmount) || raiseAmount <= 0) {
                            alert('Please enter a valid raise amount');
                            return;
                        }
                        
                        const callCost = currentGame.currentBet - myPlayer.bet;
                        const totalCost = callCost + raiseAmount;
                        
                        if (totalCost <= myPlayer.chips) {
                            myPlayer.chips -= totalCost;
                            myPlayer.bet = currentGame.currentBet + raiseAmount;
                            updates.pot += totalCost;
                            updates.currentBet = myPlayer.bet;
                            // When someone raises, only they have acted in this betting round
                            updates.playersActed = [myPlayerIndex];
                        } else {
                            alert('Insufficient chips for this raise');
                            return;
                        }
                        document.getElementById('betInput').style.display = 'none';
                        document.getElementById('raiseAmount').value = '';
                        break;
                }

                // Track that this player has acted (unless they raised, or already acted for fold)
                if (action !== 'raise' && action !== 'fold' && !updates.playersActed.includes(myPlayerIndex)) {
                    updates.playersActed.push(myPlayerIndex);
                }

                // Check if we need to advance to next stage
                if (shouldAdvanceStage(updates)) {
                    advanceStage(updates);
                } else {
                    // Move to next player
                    let nextPlayer = (updates.currentPlayer + 1) % updates.players.length;
                    
                    // Skip folded players
                    let attempts = 0;
                    while (updates.players[nextPlayer].folded && attempts < updates.players.length) {
                        nextPlayer = (nextPlayer + 1) % updates.players.length;
                        attempts++;
                    }
                    
                    // Safety check: if all players are folded except one (shouldn't happen but just in case)
                    if (attempts >= updates.players.length) {
                        advanceStage(updates);
                    } else {
                        updates.currentPlayer = nextPlayer;
                    }
                }

                await gameRef.update(updates);
            } catch (error) {
                console.error('Error performing action:', error);
                alert('Error performing action. Please try again.');
            }
        }

        function shouldAdvanceStage(gameData) {
            const activePlayers = gameData.players.filter(p => !p.folded);
            
            // If only one player left, they win
            if (activePlayers.length === 1) {
                return true;
            }
            
            // Initialize playersActed if it doesn't exist
            if (!gameData.playersActed) {
                gameData.playersActed = [];
            }
            
            // Check if all active players have matched the current bet
            const allMatched = activePlayers.every(p => p.bet === gameData.currentBet || p.chips === 0);
            
            // Count active players who need to act
            const activePlayerIndices = gameData.players
                .map((p, i) => ({ player: p, index: i }))
                .filter(({ player }) => !player.folded)
                .map(({ index }) => index);
            
            // Check if all active players have acted
            const allActivePlayersActed = activePlayerIndices.every(index => 
                gameData.playersActed.includes(index)
            );
            
            // Advance if all active players have acted and all bets are matched
            return allActivePlayersActed && allMatched;
        }

        function advanceStage(gameData) {
            // Reset bets and players acted for new betting round
            gameData.players.forEach(p => p.bet = 0);
            gameData.currentBet = 0;
            gameData.playersActed = [];
            
            // Post-flop, big blind (player 1) acts first
            if (gameData.stage !== 'preflop' && gameData.players.length === 2) {
                gameData.currentPlayer = 1;
            } else {
                gameData.currentPlayer = 0;
            }
            
            const activePlayers = gameData.players.filter(p => !p.folded);
            
            // If only one player remains, they win
            if (activePlayers.length === 1) {
                gameData.stage = 'showdown';
                determineWinner(gameData);
                return;
            }
            
            switch (gameData.stage) {
                case 'preflop':
                    gameData.stage = 'flop';
                    // Deal 3 community cards
                    for (let i = 0; i < 3; i++) {
                        gameData.communityCards.push(gameData.deck.pop());
                    }
                    break;
                    
                case 'flop':
                    gameData.stage = 'turn';
                    // Deal 1 card
                    gameData.communityCards.push(gameData.deck.pop());
                    break;
                    
                case 'turn':
                    gameData.stage = 'river';
                    // Deal 1 card
                    gameData.communityCards.push(gameData.deck.pop());
                    break;
                    
                case 'river':
                    gameData.stage = 'showdown';
                    determineWinner(gameData);
                    break;
            }
        }

        async function determineWinner(gameData) {
            const activePlayers = gameData.players.filter(p => !p.folded);
            
            if (activePlayers.length === 1) {
                // Winner by default (everyone else folded)
                const winner = activePlayers[0];
                winner.chips += gameData.pot;
                
                // Update game status
                gameData.lastWinner = {
                    name: winner.name,
                    amount: gameData.pot,
                    hand: 'Everyone folded'
                };
                
                // Check for bankruptcy
                await checkForBankruptcy(gameData);
            } else {
                // Evaluate hands
                const playerHands = activePlayers.map(player => ({
                    player,
                    hand: evaluateHand([...player.cards, ...gameData.communityCards])
                }));
                
                // Sort by hand rank
                playerHands.sort((a, b) => compareHands(b.hand, a.hand));
                
                const winner = playerHands[0].player;
                
                // Give pot to winner
                winner.chips += gameData.pot;
                
                // Update game status to show who won
                gameData.lastWinner = {
                    name: winner.name,
                    amount: gameData.pot,
                    hand: playerHands[0].hand.name
                };
                
                // Check for bankruptcy
                await checkForBankruptcy(gameData);
            }
        }
        
        async function checkForBankruptcy(gameData) {
            const bankruptPlayer = gameData.players.find(p => p.chips === 0);
            
            if (bankruptPlayer) {
                // Someone is bankrupt - show final winner
                const winner = gameData.players.find(p => p.chips > 0);
                
                // Update Firestore first
                const gameRef = db.collection('games').doc(currentGame.id);
                await gameRef.update({
                    players: gameData.players,
                    stage: 'gameover',
                    lastWinner: gameData.lastWinner
                });
                
                // Then show the winner popup
                showFinalWinner(winner, bankruptPlayer);
            } else {
                // No one bankrupt - continue to next hand
                setTimeout(async () => {
                    resetGame(gameData);
                    
                    // Update Firestore
                    const gameRef = db.collection('games').doc(currentGame.id);
                    await gameRef.update(gameData);
                }, 3000); // 3 second delay to see the showdown
            }
        }
        
        function showFinalWinner(winner, loser) {
            const announcement = document.createElement('div');
            announcement.className = 'winner-announcement';
            announcement.innerHTML = `
                <h2>ðŸ† Game Over! ðŸ†</h2>
                <p style="font-size: 2rem; color: #f39c12; margin: 20px 0;">${winner.name} Wins!</p>
                <p>${loser.name} has gone bankrupt</p>
                <p style="margin-top: 10px; font-size: 0.9rem; color: rgba(255, 255, 255, 0.7);">
                    Game ended at blinds ${currentGame.smallBlind}/${currentGame.bigBlind}
                </p>
                <p style="margin-top: 20px;">Final chip count: <strong>${winner.chips}</strong></p>
                <button class="btn btn-primary" onclick="startNewMatch()">New Game</button>
                <button class="btn btn-secondary" onclick="returnToLobby()">Return to Lobby</button>
            `;
            document.body.appendChild(announcement);
        }
        
        function startNewMatch() {
            // Close the announcement
            const announcement = document.querySelector('.winner-announcement');
            if (announcement) {
                announcement.remove();
            }
            
            // Reset both players to starting chips
            if (currentGame && currentGame.players) {
                currentGame.players.forEach(player => {
                    player.chips = 5000;
                });
                
                // Reset blinds and hand count
                currentGame.smallBlind = 25;
                currentGame.bigBlind = 50;
                currentGame.handCount = 0;
                
                // Clear the last winner and reset stage
                currentGame.lastWinner = null;
                currentGame.stage = 'preflop';
                
                // Reset game state
                resetGame(currentGame);
                
                // Update the game in Firestore
                const gameRef = db.collection('games').doc(currentGame.id);
                gameRef.update(currentGame);
            }
        }
        
        function returnToLobby() {
            // Close the announcement
            const announcement = document.querySelector('.winner-announcement');
            if (announcement) {
                announcement.remove();
            }
            
            // Leave the game
            leaveGame();
        }

        function evaluateHoleCards(cards) {
            if (cards.length !== 2) return { rank: 0, name: 'Invalid' };
            
            const rank1 = getRankValue(cards[0].rank);
            const rank2 = getRankValue(cards[1].rank);
            const suited = cards[0].suit === cards[1].suit;
            
            const highRank = Math.max(rank1, rank2);
            const lowRank = Math.min(rank1, rank2);
            
            // Pocket pair
            if (rank1 === rank2) {
                const rankNames = { 
                    14: 'Aces', 13: 'Kings', 12: 'Queens', 11: 'Jacks',
                    10: 'Tens', 9: 'Nines', 8: 'Eights', 7: 'Sevens',
                    6: 'Sixes', 5: 'Fives', 4: 'Fours', 3: 'Threes', 2: 'Twos'
                };
                const pairName = rankNames[rank1] || `${cards[0].rank}s`;
                return { rank: 1, name: `Pocket ${pairName}` };
            }
            
            // High cards
            const cardNames = { 14: 'Ace', 13: 'King', 12: 'Queen', 11: 'Jack', 10: 'Ten' };
            const highCardName = cardNames[highRank] || highRank;
            const lowCardName = cardNames[lowRank] || lowRank;
            
            // Special combinations
            if (highRank === 14 && lowRank === 13) {
                return { rank: 0.9, name: suited ? 'Big Slick (suited)' : 'Big Slick' };
            }
            
            // Connected cards
            const gap = highRank - lowRank;
            if (gap === 1) {
                return { rank: 0.5, name: `${highCardName}-${lowCardName} ${suited ? 'suited' : 'connectors'}` };
            }
            
            // Suited cards
            if (suited) {
                return { rank: 0.3, name: `${highCardName}-${lowCardName} suited` };
            }
            
            // Default
            return { rank: 0, name: `${highCardName}-${lowCardName}` };
        }

        function evaluateHand(cards) {
            if (cards.length < 5) return { rank: 0, name: 'Incomplete' };
            
            // Get all possible 5-card combinations
            const combinations = getCombinations(cards, 5);
            let bestHand = { rank: -1, name: 'High Card' };
            
            // Evaluate each combination
            for (const combo of combinations) {
                const hand = evaluateFiveCards(combo);
                if (hand.rank > bestHand.rank) {
                    bestHand = hand;
                }
            }
            
            return bestHand;
        }
        
        function getCombinations(arr, size) {
            const combinations = [];
            
            function combine(start, combo) {
                if (combo.length === size) {
                    combinations.push([...combo]);
                    return;
                }
                
                for (let i = start; i < arr.length; i++) {
                    combo.push(arr[i]);
                    combine(i + 1, combo);
                    combo.pop();
                }
            }
            
            combine(0, []);
            return combinations;
        }
        
        function evaluateFiveCards(cards) {
            const ranks = cards.map(c => getRankValue(c.rank));
            const suits = cards.map(c => c.suit);
            
            // Sort ranks in descending order
            ranks.sort((a, b) => b - a);
            
            // Count occurrences
            const rankCounts = {};
            ranks.forEach(rank => {
                rankCounts[rank] = (rankCounts[rank] || 0) + 1;
            });
            
            const counts = Object.values(rankCounts).sort((a, b) => b - a);
            const uniqueRanks = Object.keys(rankCounts).map(Number).sort((a, b) => b - a);
            
            // Check for flush
            const suitCounts = {};
            suits.forEach(suit => {
                suitCounts[suit] = (suitCounts[suit] || 0) + 1;
            });
            const isFlush = Object.values(suitCounts).some(count => count === 5);
            
            // Check for straight
            const isStraight = checkFiveStraight(uniqueRanks);
            const isWheel = uniqueRanks.length === 5 && 
                          uniqueRanks[0] === 14 && uniqueRanks[1] === 5 && 
                          uniqueRanks[2] === 4 && uniqueRanks[3] === 3 && uniqueRanks[4] === 2;
            
            // Determine hand rank
            if ((isStraight || isWheel) && isFlush) {
                if (isStraight && uniqueRanks[0] === 14 && uniqueRanks[1] === 13) {
                    return { rank: 9, name: 'Royal Flush' };
                }
                return { rank: 8, name: 'Straight Flush' };
            }
            
            // Get card names for better display
            const cardNames = { 14: 'Aces', 13: 'Kings', 12: 'Queens', 11: 'Jacks', 10: 'Tens',
                               9: 'Nines', 8: 'Eights', 7: 'Sevens', 6: 'Sixes', 5: 'Fives',
                               4: 'Fours', 3: 'Threes', 2: 'Twos' };
            
            if (counts[0] === 4) {
                const quadRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 4));
                const quadName = cardNames[quadRank] || `${quadRank}s`;
                return { rank: 7, name: `Four ${quadName}` };
            }
            
            if (counts[0] === 3 && counts[1] === 2) {
                const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3));
                const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2));
                const tripName = cardNames[tripRank] || `${tripRank}s`;
                const pairName = cardNames[pairRank] || `${pairRank}s`;
                return { rank: 6, name: `Full House` };
            }
            
            if (isFlush) return { rank: 5, name: 'Flush' };
            if (isStraight || isWheel) return { rank: 4, name: 'Straight' };
            
            if (counts[0] === 3) {
                const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3));
                const tripName = cardNames[tripRank] || `${tripRank}s`;
                return { rank: 3, name: `Three ${tripName}` };
            }
            
            if (counts[0] === 2 && counts[1] === 2) {
                return { rank: 2, name: `Two Pair` };
            }
            
            if (counts[0] === 2) {
                const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2));
                const pairName = cardNames[pairRank] || `${pairRank}s`;
                return { rank: 1, name: `Pair of ${pairName}` };
            }
            
            // High card - include the high card value
            const highCard = ranks[0];
            const highCardNames = { 14: 'Ace', 13: 'King', 12: 'Queen', 11: 'Jack', 10: 'Ten' };
            const highCardName = highCardNames[highCard] || highCard;
            return { rank: 0, name: `${highCardName} High` };
        }
        
        function checkFiveStraight(uniqueRanks) {
            if (uniqueRanks.length !== 5) return false;
            
            for (let i = 0; i < 4; i++) {
                if (uniqueRanks[i] - uniqueRanks[i + 1] !== 1) {
                    return false;
                }
            }
            return true;
        }

        function getRankValue(rank) {
            const values = { 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
            return values[rank] || parseInt(rank);
        }

        function compareHands(a, b) {
            if (a.rank !== b.rank) return a.rank - b.rank;
            if (a.highCard && b.highCard) return a.highCard - b.highCard;
            return 0;
        }

        function showWinner(winner, pot, hand) {
            const announcement = document.createElement('div');
            announcement.className = 'winner-announcement';
            announcement.innerHTML = `
                <h2>ðŸŽ‰ Winner! ðŸŽ‰</h2>
                <p>${winner.name} wins ${pot} chips!</p>
                ${hand ? `<p style="color: #f39c12; font-size: 1.3rem;">With: ${hand.name}</p>` : ''}
                <button class="btn btn-primary" onclick="closeWinnerAnnouncement()">Continue</button>
            `;
            document.body.appendChild(announcement);
        }

        function closeWinnerAnnouncement() {
            const announcement = document.querySelector('.winner-announcement');
            if (announcement) {
                announcement.remove();
            }
        }

        function resetGame(gameData) {
            // Rotate dealer position (swap players for heads-up)
            if (gameData.players.length === 2) {
                // Swap player positions to rotate dealer/blinds
                [gameData.players[0], gameData.players[1]] = [gameData.players[1], gameData.players[0]];
            }
            
            // Reset for next hand
            gameData.deck = createDeck();
            gameData.communityCards = [];
            gameData.pot = 0;
            gameData.currentBet = 0;
            gameData.currentPlayer = 0;
            gameData.stage = 'preflop';
            gameData.playersActed = [];
            
            gameData.players.forEach(player => {
                player.cards = [];
                player.bet = 0;
                player.folded = false;
            });
            
            // Only deal if no one is bankrupt
            const bankruptPlayer = gameData.players.find(p => p.chips === 0);
            if (!bankruptPlayer) {
                dealCards(gameData);
            }
        }
        // Initialize app
        window.addEventListener('load', () => {
            // Show mobile hint
            if (isMobile) {
                const mobileHint = document.querySelector('.mobile-hint');
                if (mobileHint) {
                    mobileHint.style.display = 'block';
                }
                
                // Add viewport meta tag for better mobile experience
                if (!document.querySelector('meta[name="viewport"]')) {
                    const viewport = document.createElement('meta');
                    viewport.name = 'viewport';
                    viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
                    document.head.appendChild(viewport);
                }
                
                // Prevent double-tap zoom on iOS
                let lastTouchEnd = 0;
                document.addEventListener('touchend', (e) => {
                    const now = Date.now();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);
            }
            
            // Handle orientation change
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    window.scrollTo(0, 0);
                }, 100);
            });
        });
    </script>
</body>
</html>