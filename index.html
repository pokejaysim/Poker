<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Texas Hold'em Poker - Live Multiplayer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Mobile-specific body styles */
        @media (max-width: 768px) {
            body {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                /* Hide scrollbar on mobile */
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            
            body::-webkit-scrollbar {
                display: none;
            }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Compact desktop layout */
        @media (min-width: 769px) {
            .container {
                padding: 10px 20px;
            }
        }

        .lobby {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }

        .lobby h1 {
            font-size: 4rem;
            margin-bottom: 2rem;
            background: linear-gradient(45deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(243, 156, 18, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        .mobile-hint {
            display: none;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 20px;
            font-size: 1.1rem;
            animation: fadeIn 1s ease-in;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 20px rgba(243, 156, 18, 0.5)); }
            to { filter: drop-shadow(0 0 30px rgba(231, 76, 60, 0.8)); }
        }

        .lobby-actions {
            display: flex;
            gap: 20px;
            margin-bottom: 2rem;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.2rem;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        .btn-primary {
            background: linear-gradient(45deg, #e74c3c, #f39c12);
            color: white;
            box-shadow: 0 5px 20px rgba(231, 76, 60, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(231, 76, 60, 0.6);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group input {
            padding: 15px 25px;
            font-size: 1.1rem;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            width: 300px;
        }

        .input-group input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .input-group input:focus {
            outline: none;
            border-color: #f39c12;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.3);
        }

        .game-container {
            display: none;
            position: relative;
        }

        .game-layout {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .game-main {
            flex: 1;
            min-width: 0;
        }

        .game-table {
            position: relative;
            background: radial-gradient(ellipse at center, #2d4a2b 0%, #1a2f19 100%);
            border-radius: 200px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), inset 0 0 100px rgba(0, 0, 0, 0.5);
            margin: 20px auto;
            max-width: 1000px;
            border: 10px solid #3e2723;
        }

        /* Compact desktop game table */
        @media (min-width: 769px) {
            .game-table {
                padding: 25px 40px;
                margin: 10px auto;
            }
        }

        .community-cards {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 40px 0;
            min-height: 120px;
        }

        /* Compact desktop community cards */
        @media (min-width: 769px) {
            .community-cards {
                margin: 20px 0;
                min-height: 110px;
            }
        }

        .card {
            width: 80px;
            height: 110px;
            border-radius: 10px;
            background: linear-gradient(135deg, #fff 0%, #f0f0f0 100%);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            animation: dealCard 0.5s ease-out;
        }

        @keyframes dealCard {
            from {
                transform: translateY(-50px) rotateY(180deg) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translateY(0) rotateY(0) scale(1);
                opacity: 1;
            }
        }

        .card.red { color: #e74c3c; }
        .card.black { color: #2c3e50; }

        .card.back {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: transparent;
        }

        .card.back::before {
            content: 'â™ ';
            position: absolute;
            font-size: 3rem;
            color: rgba(255, 255, 255, 0.1);
            transform: rotate(45deg);
        }

        .players-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 40px;
        }

        /* Compact desktop players container */
        @media (min-width: 769px) {
            .players-container {
                margin-bottom: 20px;
            }
        }

        .player-slot {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            min-width: 200px;
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
        }

        /* Compact desktop player slots */
        @media (min-width: 769px) {
            .player-slot {
                padding: 15px;
            }
        }

        .position-indicator {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #f39c12;
            color: #000;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
            z-index: 10;
            animation: rotateIn 0.5s ease-out;
        }
        
        @keyframes rotateIn {
            from {
                transform: rotate(-180deg) scale(0);
                opacity: 0;
            }
            to {
                transform: rotate(0) scale(1);
                opacity: 1;
            }
        }

        .position-indicator.dealer {
            background: #f39c12;
            font-size: 0.75rem;
            letter-spacing: -0.5px;
        }

        .position-indicator.small-blind {
            background: #3498db;
            width: 30px;
            height: 30px;
            font-size: 0.8rem;
        }

        .position-indicator.big-blind {
            background: #e74c3c;
            width: 30px;
            height: 30px;
            font-size: 0.8rem;
        }

        .player-slot.active {
            border-color: #f39c12;
            box-shadow: 0 0 30px rgba(243, 156, 18, 0.5);
        }

        .player-slot.current-player {
            background: rgba(243, 156, 18, 0.2);
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #f39c12;
        }

        /* Compact desktop player name */
        @media (min-width: 769px) {
            .player-name {
                font-size: 1.1rem;
                margin-bottom: 8px;
            }
        }

        .player-chips {
            font-size: 1.1rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Compact desktop player chips */
        @media (min-width: 769px) {
            .player-chips {
                font-size: 1rem;
                margin-bottom: 8px;
            }
        }

        .player-hand-rank {
            font-size: 0.9rem;
            color: #3498db;
            margin-bottom: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 5px 10px;
            background: rgba(52, 152, 219, 0.2);
            border-radius: 20px;
            display: inline-block;
            animation: fadeIn 0.3s ease-in;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        /* Compact desktop hand rank */
        @media (min-width: 769px) {
            .player-hand-rank {
                font-size: 0.85rem;
                padding: 4px 8px;
                margin-bottom: 8px;
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .player-hand-rank.strong {
            color: #2ecc71;
            background: rgba(46, 204, 113, 0.2);
        }

        .player-hand-rank.very-strong {
            color: #e74c3c;
            background: rgba(231, 76, 60, 0.2);
            animation: glow 1s ease-in-out infinite alternate;
        }

        .chip-icon {
            width: 20px;
            height: 20px;
            background: #f39c12;
            border-radius: 50%;
            display: inline-block;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
        }

        .player-cards {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            min-height: 110px;
        }

        /* Compact desktop player cards */
        @media (min-width: 769px) {
            .player-cards {
                margin-top: 10px;
                min-height: 110px;
            }
        }

        .pot-info {
            text-align: center;
            margin: 30px 0;
            font-size: 1.8rem;
            font-weight: bold;
            color: #f39c12;
            text-shadow: 0 0 20px rgba(243, 156, 18, 0.5);
        }

        /* Compact desktop pot info */
        @media (min-width: 769px) {
            .pot-info {
                margin: 15px 0;
                font-size: 1.6rem;
            }
            
            .pot-info > div {
                font-size: 0.7rem;
                margin-top: 3px;
            }
        }

        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        /* Compact desktop action buttons */
        @media (min-width: 769px) {
            .action-buttons {
                margin-top: 15px;
            }
        }

        .action-btn {
            padding: 12px 30px;
            font-size: 1rem;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .btn-fold {
            background: #e74c3c;
            color: white;
        }

        .btn-call {
            background: #3498db;
            color: white;
        }

        .btn-raise {
            background: #2ecc71;
            color: white;
        }

        .btn-check {
            background: #95a5a6;
            color: white;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .bet-input {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        /* Compact desktop bet input */
        @media (min-width: 769px) {
            .bet-input {
                margin-top: 15px;
            }
        }

        .bet-input input {
            padding: 10px 20px;
            font-size: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            width: 150px;
        }

        .game-status {
            text-align: center;
            font-size: 1.2rem;
            margin: 20px 0;
            color: #ecf0f1;
            min-height: 30px;
        }

        /* Compact desktop game status */
        @media (min-width: 769px) {
            .game-status {
                margin: 10px 0;
                font-size: 1.1rem;
                min-height: 25px;
            }
        }

        .winner-announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            z-index: 1000;
            animation: winnerPop 0.5s ease-out;
            backdrop-filter: blur(10px);
            border: 3px solid #f39c12;
            box-shadow: 0 0 50px rgba(243, 156, 18, 0.5);
        }

        @keyframes winnerPop {
            from {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .winner-announcement h2 {
            font-size: 3rem;
            color: #f39c12;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(243, 156, 18, 0.8);
        }

        .winner-announcement p {
            font-size: 1.5rem;
            margin-bottom: 20px;
        }

        .winner-announcement .btn {
            margin: 10px;
        }

        .room-code {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 1.2rem;
            letter-spacing: 2px;
            margin: 20px 0;
            display: inline-block;
        }

        /* Compact desktop room code */
        @media (min-width: 769px) {
            .room-code {
                margin: 10px 0;
                padding: 8px 16px;
                font-size: 1.1rem;
            }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #f39c12;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .login-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }

        .login-container h1 {
            font-size: 4rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(243, 156, 18, 0.5);
        }

        .login-container p {
            font-size: 1.2rem;
            margin-bottom: 3rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .divider {
            display: flex;
            align-items: center;
            margin: 30px auto;
            width: 100%;
            max-width: 400px;
        }

        .divider::before,
        .divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255, 255, 255, 0.2);
        }

        .divider span {
            padding: 0 20px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
        }

        .google-signin-btn {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 30px;
            background: white;
            color: #333;
            border: none;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .google-signin-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
        }

        .google-icon {
            width: 24px;
            height: 24px;
        }

        .user-info {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
        }

        /* Compact desktop user info */
        @media (min-width: 769px) {
            .user-info {
                top: 10px;
                right: 10px;
                padding: 8px 16px;
                gap: 12px;
            }
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #f39c12;
        }

        /* Compact desktop avatar */
        @media (min-width: 769px) {
            .user-avatar {
                width: 35px;
                height: 35px;
            }
        }

        .user-name {
            font-weight: 600;
            color: #f39c12;
        }

        .user-name.guest {
            font-style: italic;
            opacity: 0.9;
        }

        .sign-out-btn {
            padding: 8px 16px;
            background: rgba(231, 76, 60, 0.8);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .sign-out-btn:hover {
            background: rgba(231, 76, 60, 1);
        }

        .hand-guide {
            margin-top: 20px;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
        }

        /* Compact desktop hand guide */
        @media (min-width: 769px) {
            .hand-guide {
                margin-top: 10px;
                font-size: 0.85rem;
            }
        }

        .hand-guide summary {
            cursor: pointer;
            color: #f39c12;
            font-weight: 600;
            padding: 10px;
            background: rgba(243, 156, 18, 0.1);
            border-radius: 20px;
            display: inline-block;
            transition: all 0.3s ease;
        }

        /* Compact desktop hand guide summary */
        @media (min-width: 769px) {
            .hand-guide summary {
                padding: 6px 12px;
                font-size: 0.85rem;
            }
        }

        .hand-guide summary:hover {
            background: rgba(243, 156, 18, 0.2);
        }

        .hand-guide div {
            margin-top: 10px;
            text-align: left;
            max-width: 400px;
            margin: 10px auto;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        /* Compact desktop hand guide content */
        @media (min-width: 769px) {
            .hand-guide div {
                padding: 10px;
                font-size: 0.8rem;
            }
        }

        .hand-guide div > div {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .hand-guide div > div:last-child {
            border-bottom: none;
        }

        /* Chat Styles */
        .chat-container {
            width: 350px;
            height: 600px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .chat-header {
            padding: 15px;
            background: rgba(243, 156, 18, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 13px 13px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header h3 {
            margin: 0;
            color: #f39c12;
            font-size: 1.2rem;
        }

        .chat-toggle {
            display: none;
            background: rgba(243, 156, 18, 0.2);
            border: none;
            color: #f39c12;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(243, 156, 18, 0.3);
            border-radius: 3px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: rgba(243, 156, 18, 0.5);
        }

        .chat-message {
            display: flex;
            gap: 10px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .chat-message.own {
            flex-direction: row-reverse;
        }

        .chat-message.own .message-content {
            background: rgba(243, 156, 18, 0.2);
            border-color: rgba(243, 156, 18, 0.3);
        }

        .chat-message.system {
            justify-content: center;
        }

        .chat-message.system .message-content {
            background: rgba(52, 152, 219, 0.1);
            border-color: rgba(52, 152, 219, 0.3);
            color: #3498db;
            font-style: italic;
            font-size: 0.9rem;
        }

        .message-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            flex-shrink: 0;
            border: 2px solid rgba(243, 156, 18, 0.5);
        }

        .message-content {
            max-width: 70%;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            word-wrap: break-word;
        }

        .message-author {
            font-weight: 600;
            color: #f39c12;
            font-size: 0.85rem;
            margin-bottom: 3px;
        }

        .message-text {
            color: #ecf0f1;
            font-size: 0.95rem;
            line-height: 1.4;
        }

        .message-time {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 3px;
        }

        .chat-input-container {
            padding: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 10px;
        }

        .chat-input {
            flex: 1;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: white;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .chat-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .chat-input:focus {
            outline: none;
            border-color: #f39c12;
            background: rgba(255, 255, 255, 0.15);
        }

        .chat-send-btn {
            padding: 10px 20px;
            background: linear-gradient(45deg, #e74c3c, #f39c12);
            border: none;
            border-radius: 25px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .chat-send-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(243, 156, 18, 0.4);
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Mobile Chat Styles */
        .mobile-chat-toggle {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: linear-gradient(45deg, #e74c3c, #f39c12);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            z-index: 100;
            transition: all 0.3s ease;
        }

        .mobile-chat-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
        }

        .chat-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #e74c3c;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .lobby h1, .login-container h1 {
                font-size: 2.5rem;
            }
            
            .lobby-actions {
                flex-direction: column;
                width: 100%;
                max-width: 300px;
            }
            
            .btn {
                width: 100%;
                padding: 18px 30px;
                font-size: 1.1rem;
            }
            
            .input-group input {
                width: 100%;
                max-width: 300px;
            }
            
            .user-info {
                position: fixed !important;
                top: 10px;
                right: 10px;
                padding: 8px 15px;
                flex-direction: row;
                gap: 10px;
            }
            
            .user-avatar {
                width: 30px;
                height: 30px;
            }
            
            .user-name {
                display: none;
            }
            
            .sign-out-btn {
                padding: 6px 12px;
                font-size: 0.8rem;
            }
            
            .game-layout {
                flex-direction: column;
            }
            
            .game-table {
                padding: 15px;
                border-radius: 20px;
                margin: 10px;
                border-width: 5px;
            }
            
            .room-code {
                font-size: 1rem;
                padding: 8px 15px;
                margin: 10px 0;
            }
            
            .players-container {
                flex-direction: column;
                gap: 15px;
                margin-bottom: 20px;
            }
            
            .player-slot {
                width: 100%;
                padding: 15px;
                min-width: unset;
            }
            
            .player-name {
                font-size: 1.1rem;
                margin-bottom: 8px;
            }
            
            .player-chips {
                font-size: 1rem;
                margin-bottom: 8px;
            }
            
            .player-hand-rank {
                font-size: 0.85rem;
                padding: 4px 8px;
                margin-bottom: 8px;
            }
            
            .player-cards {
                display: flex;
                gap: 5px;
                justify-content: center;
                min-height: 85px;
            }
            
            .community-cards {
                gap: 8px;
                margin: 20px 0;
                min-height: 85px;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .card {
                width: 50px;
                height: 70px;
                font-size: 1.2rem;
                border-radius: 8px;
            }
            
            .card.back::before {
                font-size: 2rem;
            }
            
            .position-indicator {
                width: 25px;
                height: 25px;
                font-size: 0.7rem;
                top: -8px;
                right: -8px;
            }
            
            .pot-info {
                font-size: 1.4rem;
                margin: 20px 0;
            }
            
            .pot-info div {
                font-size: 0.7rem;
                margin-top: 3px;
            }
            
            .game-status {
                font-size: 1rem;
                margin: 15px 0;
                padding: 0 10px;
                text-align: center;
            }
            
            .hand-guide {
                margin-top: 15px;
            }
            
            .hand-guide summary {
                font-size: 0.85rem;
                padding: 8px 15px;
            }
            
            .hand-guide div {
                font-size: 0.8rem;
                padding: 10px;
            }
            
            .action-buttons {
                gap: 10px;
                margin-top: 20px;
                position: fixed;
                bottom: 20px;
                left: 10px;
                right: 10px;
                background: rgba(0, 0, 0, 0.8);
                padding: 15px;
                border-radius: 20px;
                backdrop-filter: blur(10px);
                z-index: 100;
            }
            
            .action-btn {
                padding: 15px 20px;
                font-size: 0.95rem;
                min-width: 80px;
                flex: 1;
            }
            
            .bet-input {
                position: fixed;
                bottom: 100px;
                left: 10px;
                right: 10px;
                background: rgba(0, 0, 0, 0.9);
                padding: 15px;
                border-radius: 20px;
                backdrop-filter: blur(10px);
                z-index: 101;
                gap: 10px;
            }
            
            .bet-input input {
                flex: 1;
                padding: 12px 20px;
                font-size: 1rem;
            }
            
            .bet-input .btn-raise {
                flex: 0 0 auto;
            }
            
            .winner-announcement {
                padding: 30px;
                width: 90%;
                max-width: 350px;
            }
            
            .winner-announcement h2 {
                font-size: 2rem;
            }
            
            .winner-announcement p {
                font-size: 1.2rem;
            }
            
            .winner-announcement .btn {
                width: 100%;
                margin: 5px 0;
            }
            
            /* Add padding to bottom to account for fixed action buttons */
            .game-table {
                padding-bottom: 100px;
            }
            
            /* Mobile chat styles */
            .chat-container {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                width: 100%;
                height: 100%;
                max-width: none;
                border-radius: 0;
                z-index: 200;
            }
            
            .chat-container.mobile-visible {
                display: flex;
            }
            
            .mobile-chat-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
                bottom: 90px;
            }
            
            .chat-header {
                padding: 20px;
            }
            
            .chat-toggle {
                display: block;
            }
        }

        /* Tablet specific adjustments */
        @media (min-width: 769px) and (max-width: 1024px) {
            .game-table {
                max-width: 800px;
                padding: 25px;
            }
            
            .card {
                width: 70px;
                height: 95px;
                font-size: 1.7rem;
            }
            
            .player-slot {
                min-width: 180px;
                padding: 15px;
            }
            
            .community-cards {
                margin: 25px 0;
            }
            
            .pot-info {
                margin: 20px 0;
            }
            
            .chat-container {
                width: 300px;
                height: 500px;
            }
        }

        /* Large desktop enhancements */
        @media (min-width: 1400px) {
            .container {
                max-width: 1600px;
            }
            
            .game-table {
                max-width: 1200px;
                padding: 35px 45px;
            }
            
            .card {
                width: 85px;
                height: 120px;
                font-size: 2.3rem;
            }
            
            .player-slot {
                min-width: 230px;
                padding: 20px;
            }
            
            .player-name {
                font-size: 1.3rem;
            }
            
            .pot-info {
                font-size: 1.9rem;
                margin: 20px 0;
            }
            
            .community-cards {
                margin: 30px 0;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .btn:active, .action-btn:active {
                transform: scale(0.95);
            }
            
            .card {
                /* Prevent text selection on cards */
                -webkit-user-select: none;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
            }
        }

        /* Landscape mode on mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .container {
                padding: 5px;
            }
            
            .game-table {
                padding: 10px;
                margin: 5px;
            }
            
            .players-container {
                flex-direction: row;
                gap: 10px;
            }
            
            .player-slot {
                padding: 10px;
                width: 48%;
            }
            
            .card {
                width: 45px;
                height: 65px;
                font-size: 1.1rem;
            }
            
            .action-buttons {
                bottom: 10px;
                padding: 10px;
            }
            
            .action-btn {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .game-table {
                padding-bottom: 80px;
            }
            
            .pot-info {
                font-size: 1.2rem;
                margin: 15px 0;
            }
            
            .hand-guide {
                display: none;
            }
            
            .mobile-chat-toggle {
                bottom: 70px;
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }
        }

        /* Notch/Safe area support for modern phones */
        @supports (padding: max(0px)) {
            .container {
                padding-left: max(20px, env(safe-area-inset-left));
                padding-right: max(20px, env(safe-area-inset-right));
            }
            
            @media (max-width: 768px) {
                .action-buttons {
                    bottom: max(20px, env(safe-area-inset-bottom));
                    left: max(10px, env(safe-area-inset-left));
                    right: max(10px, env(safe-area-inset-right));
                }
                
                .mobile-chat-toggle {
                    bottom: max(90px, calc(70px + env(safe-area-inset-bottom)));
                    right: max(20px, env(safe-area-inset-right));
                }
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="login-container" id="loginScreen">
            <h1>Texas Hold'em Poker</h1>
            <p>Sign in to start playing</p>
            <button class="google-signin-btn" onclick="signInWithGoogle()">
                <svg class="google-icon" viewBox="0 0 24 24">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Sign in with Google
            </button>
            <div class="divider"><span>or</span></div>
            <button class="btn btn-secondary" onclick="signInAnonymously()">
                Play as Guest
            </button>
        </div>

        <div class="lobby" id="lobby" style="display: none;">
            <div class="user-info" id="userInfo">
                <img class="user-avatar" id="userAvatar" src="" alt="Avatar" onerror="this.src='https://www.gravatar.com/avatar/?d=mp&s=200'">
                <span class="user-name" id="userName"></span>
                <button class="sign-out-btn" onclick="signOut()">Sign Out</button>
            </div>
            <h1>Texas Hold'em Poker</h1>
            <p class="mobile-hint" style="display: none; color: rgba(255, 255, 255, 0.7); margin-bottom: 20px;">Swipe or tap to play!</p>
            <div class="lobby-actions">
                <button class="btn btn-primary" onclick="createGame()">Create Game</button>
                <button class="btn btn-secondary" onclick="showJoinGame()">Join Game</button>
            </div>
            <div id="joinGameSection" style="display: none;">
                <div class="input-group">
                    <input type="text" id="roomCode" placeholder="Enter room code" maxlength="6" autocomplete="off" autocorrect="off" autocapitalize="off">
                </div>
                <button class="btn btn-primary" onclick="joinGame()">Join</button>
            </div>
        </div>

        <div class="game-container" id="gameContainer" style="display: none;">
            <div class="game-layout">
                <div class="game-main">
                    <div class="game-table" id="gameTable">
                        <div class="user-info" style="position: relative; margin-bottom: 20px;">
                            <img class="user-avatar" id="gameUserAvatar" src="" alt="Avatar" onerror="this.src='https://www.gravatar.com/avatar/?d=mp&s=200'">
                            <span class="user-name" id="gameUserName"></span>
                            <button class="sign-out-btn" onclick="leaveGame()">Leave Game</button>
                        </div>
                        <div class="room-code" id="roomCodeDisplay"></div>
                        
                        <div class="players-container">
                            <div class="player-slot" id="player1">
                                <div class="position-indicator" style="display: none;"></div>
                                <div class="player-name">Waiting for player...</div>
                                <div class="player-chips"></div>
                                <div class="player-hand-rank" style="display: none;"></div>
                                <div class="player-cards"></div>
                            </div>
                            <div class="player-slot" id="player2">
                                <div class="position-indicator" style="display: none;"></div>
                                <div class="player-name">Waiting for player...</div>
                                <div class="player-chips"></div>
                                <div class="player-hand-rank" style="display: none;"></div>
                                <div class="player-cards"></div>
                            </div>
                        </div>

                        <div class="pot-info">
                            Pot: <span class="chip-icon"></span> <span id="potAmount">0</span>
                            <div style="font-size: 0.8rem; margin-top: 5px; color: rgba(255, 255, 255, 0.7);">
                                Blinds: <span id="blindsInfo">25/50</span> â€¢ Hand #<span id="handCount">0</span>
                                <span style="display: block; font-size: 0.7rem; margin-top: 3px;">
                                    (Blinds double every 5 hands)
                                </span>
                            </div>
                        </div>
                        
                        <div class="community-cards" id="communityCards"></div>
                        
                        <div class="game-status" id="gameStatus">Waiting for players...</div>
                        
                        <div class="hand-guide">
                            <details>
                                <summary>Poker Hand Rankings â–¼</summary>
                                <div>
                                    <div>ðŸ”´ <strong>Royal Flush</strong> - A, K, Q, J, 10 (same suit)</div>
                                    <div>ðŸŸ  <strong>Straight Flush</strong> - 5 cards in sequence (same suit)</div>
                                    <div>ðŸŸ¡ <strong>Four of a Kind</strong> - 4 cards of same rank</div>
                                    <div>ðŸŸ¢ <strong>Full House</strong> - 3 of a kind + pair</div>
                                    <div>ðŸ”µ <strong>Flush</strong> - 5 cards of same suit</div>
                                    <div>ðŸŸ£ <strong>Straight</strong> - 5 cards in sequence</div>
                                    <div>âš« <strong>Three of a Kind</strong> - 3 cards of same rank</div>
                                    <div>âšª <strong>Two Pair</strong> - 2 pairs</div>
                                    <div>ðŸ”˜ <strong>Pair</strong> - 2 cards of same rank</div>
                                    <div>â­• <strong>High Card</strong> - Highest card wins</div>
                                </div>
                            </details>
                        </div>
                        
                        <div class="action-buttons" id="actionButtons" style="display: none;">
                            <button class="action-btn btn-fold" onclick="playerAction('fold')">Fold</button>
                            <button class="action-btn btn-check" onclick="playerAction('check')">Check</button>
                            <button class="action-btn btn-call" onclick="playerAction('call')">Call</button>
                            <button class="action-btn btn-raise" onclick="showRaiseInput()">Raise</button>
                        </div>
                        
                        <div class="bet-input" id="betInput" style="display: none;">
                            <input type="number" id="raiseAmount" min="1" placeholder="Amount" inputmode="numeric" pattern="[0-9]*">
                            <button class="action-btn btn-raise" onclick="playerAction('raise')">Confirm Raise</button>
                        </div>
                    </div>
                </div>
                
                <div class="chat-container" id="chatContainer">
                    <div class="chat-header">
                        <h3>Game Chat</h3>
                        <button class="chat-toggle" onclick="toggleMobileChat()">âœ•</button>
                    </div>
                    <div class="chat-messages" id="chatMessages"></div>
                    <div class="chat-input-container">
                        <input type="text" class="chat-input" id="chatInput" placeholder="Type a message..." maxlength="200">
                        <button class="chat-send-btn" id="chatSendBtn" onclick="sendMessage()">Send</button>
                    </div>
                </div>
            </div>
            
            <button class="mobile-chat-toggle" id="mobileChatToggle" onclick="toggleMobileChat()">
                ðŸ’¬
                <span class="chat-badge" id="chatBadge" style="display: none;">0</span>
            </button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.7.1/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.7.1/firebase-firestore-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.7.1/firebase-auth-compat.min.js"></script>
    
    <script>
        // Detect mobile device
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   window.innerWidth <= 768 ||
                   ('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0);
        }
        
        let isMobile = isMobileDevice();
        
        // Update mobile detection on resize
        window.addEventListener('resize', () => {
            isMobile = isMobileDevice();
        });
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDNnyiWr2HIHsvL69LboLoUCIzVmvfanW8",
            authDomain: "poker-7eeef.firebaseapp.com",
            projectId: "poker-7eeef",
            storageBucket: "poker-7eeef.firebasestorage.app",
            messagingSenderId: "203143203913",
            appId: "1:203143203913:web:ea195b6158c16c61280398"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();
        
        // Set persistence to LOCAL (default) to maintain sessions
        auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL)
            .catch((error) => {
                console.error('Error setting persistence:', error);
            });

        // Game state
        let currentGame = null;
        let playerId = null;
        let playerName = null;
        let playerPhotoURL = null;
        let gameListener = null;
        let chatListener = null;
        let unreadMessages = 0;

        // Auth state observer
        auth.onAuthStateChanged((user) => {
            if (user) {
                // User is signed in
                playerId = user.uid;
                
                // Handle anonymous users
                if (user.isAnonymous) {
                    const guestNames = ['Ace', 'King', 'Queen', 'Jack', 'Royal', 'Flush', 'Bluff', 'Shark', 'Pro'];
                    const randomName = guestNames[Math.floor(Math.random() * guestNames.length)];
                    playerName = randomName + '_' + user.uid.substring(0, 4).toUpperCase();
                    playerPhotoURL = 'https://www.gravatar.com/avatar/?d=identicon&s=200';
                } else {
                    playerName = user.displayName;
                    playerPhotoURL = user.photoURL;
                }
                
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('lobby').style.display = 'flex';
                document.getElementById('userName').textContent = playerName;
                document.getElementById('userName').className = 'user-name' + (user.isAnonymous ? ' guest' : '');
                document.getElementById('userAvatar').src = playerPhotoURL;
            } else {
                // User is signed out
                document.getElementById('loginScreen').style.display = 'flex';
                document.getElementById('lobby').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'none';
                
                // Clean up any active game listeners
                if (gameListener) {
                    gameListener();
                    gameListener = null;
                }
                if (chatListener) {
                    chatListener();
                    chatListener = null;
                }
            }
        });

        // Sign in with Google
        window.signInWithGoogle = async function() {
            const provider = new firebase.auth.GoogleAuthProvider();
            try {
                await auth.signInWithPopup(provider);
            } catch (error) {
                console.error('Error signing in with Google:', error);
                console.error('Error code:', error.code);
                console.error('Error message:', error.message);
                
                // Provide more specific error messages
                if (error.code === 'auth/popup-blocked') {
                    alert('Popup was blocked. Please allow popups for this site.');
                } else if (error.code === 'auth/unauthorized-domain') {
                    alert('This domain is not authorized. Please add it to Firebase authorized domains.');
                } else if (error.code === 'auth/operation-not-allowed') {
                    alert('Google sign-in is not enabled. Please enable it in Firebase Console.');
                } else {
                    alert(`Error signing in: ${error.message}`);
                }
            }
        }

        // Sign in anonymously
        window.signInAnonymously = async function() {
            try {
                await auth.signInAnonymously();
            } catch (error) {
                console.error('Error signing in anonymously:', error);
                console.error('Error code:', error.code);
                console.error('Error message:', error.message);
                
                // Provide more specific error messages
                if (error.code === 'auth/operation-not-allowed') {
                    alert('Anonymous sign-in is not enabled. Please enable it in Firebase Console.');
                } else {
                    alert(`Error signing in as guest: ${error.message}`);
                }
            }
        }

        // Sign out
        window.signOut = async function() {
            try {
                await auth.signOut();
                currentGame = null;
                playerId = null;
                playerName = null;
            } catch (error) {
                console.error('Error signing out:', error);
            }
        }

        // Card deck
        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const suitColors = { 'â™ ': 'black', 'â™£': 'black', 'â™¥': 'red', 'â™¦': 'red' };

        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function createDeck() {
            const deck = [];
            for (const suit of suits) {
                for (const rank of ranks) {
                    deck.push({ suit, rank });
                }
            }
            return shuffleDeck(deck);
        }

        function shuffleDeck(deck) {
            const newDeck = [...deck];
            for (let i = newDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
            }
            return newDeck;
        }

        window.createGame = async function() {
            if (!auth.currentUser) {
                alert('Please sign in first');
                return;
            }

            const roomCode = generateRoomCode();
            
            const gameData = {
                roomCode,
                players: [{
                    id: playerId,
                    name: playerName,
                    chips: 5000,
                    cards: [],
                    bet: 0,
                    folded: false
                }],
                deck: createDeck(),
                communityCards: [],
                pot: 0,
                currentPlayer: 0,
                dealerPosition: 0,
                stage: 'waiting', // waiting, preflop, flop, turn, river, showdown
                currentBet: 0,
                playersActed: [],
                lastWinner: null,
                handCount: 0,
                smallBlind: 25,
                bigBlind: 50,
                created: firebase.firestore.FieldValue.serverTimestamp()
            };

            try {
                await db.collection('games').doc(roomCode).set(gameData);
                console.log('Created new game:', roomCode);
                
                // Send system message
                await sendSystemMessage(roomCode, `${playerName} created the game`);
                
                startGameListener(roomCode);
                startChatListener(roomCode);
                showGame(roomCode);
            } catch (error) {
                console.error('Error creating game:', error);
                alert('Error creating game. Please try again.');
            }
        }

        window.showJoinGame = function() {
            document.getElementById('joinGameSection').style.display = 'block';
        }

        window.joinGame = async function() {
            if (!auth.currentUser) {
                alert('Please sign in first');
                return;
            }
            
            const roomCode = document.getElementById('roomCode').value.trim().toUpperCase();
            
            if (!roomCode) {
                alert('Please enter a room code');
                return;
            }

            try {
                const gameRef = db.collection('games').doc(roomCode);
                const gameDoc = await gameRef.get();
                
                if (!gameDoc.exists) {
                    alert('Game not found');
                    return;
                }

                const gameData = gameDoc.data();
                
                if (gameData.players.length >= 2) {
                    alert('Game is full');
                    return;
                }

                gameData.players.push({
                    id: playerId,
                    name: playerName,
                    chips: 5000,
                    cards: [],
                    bet: 0,
                    folded: false
                });

                // Send system message
                await sendSystemMessage(roomCode, `${playerName} joined the game`);

                // If game state is incomplete, initialize missing fields
                if (!gameData.hasOwnProperty('smallBlind')) {
                    gameData.smallBlind = 25;
                    gameData.bigBlind = 50;
                    gameData.handCount = 0;
                }
                
                if (gameData.players.length === 2) {
                    gameData.stage = 'preflop';
                    gameData.currentPlayer = 0;
                    gameData.playersActed = [];
                    gameData.currentBet = 0;
                    gameData.pot = 0;
                    gameData.handCount = gameData.handCount || 0;
                    gameData.smallBlind = gameData.smallBlind || 25;
                    gameData.bigBlind = gameData.bigBlind || 50;
                    
                    // Deal cards and post blinds
                    dealCards(gameData);
                    
                    // Send system message
                    await sendSystemMessage(roomCode, 'Game started! Dealing cards...');
                    
                    // Log the state after dealing to debug
                    console.log('After dealing cards and posting blinds:');
                    console.log('Player 0:', gameData.players[0].name, 'Chips:', gameData.players[0].chips, 'Bet:', gameData.players[0].bet);
                    console.log('Player 1:', gameData.players[1].name, 'Chips:', gameData.players[1].chips, 'Bet:', gameData.players[1].bet);
                    console.log('Pot:', gameData.pot, 'Current Bet:', gameData.currentBet);
                    
                    // Update the game with all changes including blinds
                    await gameRef.update({
                        players: gameData.players,
                        stage: gameData.stage,
                        pot: gameData.pot,
                        currentBet: gameData.currentBet,
                        deck: gameData.deck,
                        handCount: gameData.handCount,
                        playersActed: gameData.playersActed,
                        smallBlind: gameData.smallBlind,
                        bigBlind: gameData.bigBlind
                    });
                    
                    startGameListener(roomCode);
                    startChatListener(roomCode);
                    showGame(roomCode);
                    return;
                }

                await gameRef.update(gameData);
                startGameListener(roomCode);
                startChatListener(roomCode);
                showGame(roomCode);
            } catch (error) {
                console.error('Error joining game:', error);
                alert('Error joining game. Please try again.');
            }
        }

        function dealCards(gameData) {
            // Increment hand count
            gameData.handCount = (gameData.handCount || 0) + 1;
            
            // Check if we need to increase blinds (every 5 hands)
            if (gameData.handCount > 1 && (gameData.handCount - 1) % 5 === 0) {
                gameData.smallBlind *= 2;
                gameData.bigBlind *= 2;
            }
            
            // Deal 2 cards to each player
            for (let i = 0; i < gameData.players.length; i++) {
                gameData.players[i].cards = [
                    gameData.deck.pop(),
                    gameData.deck.pop()
                ];
                gameData.players[i].bet = 0;
                gameData.players[i].folded = false;
            }
            
            // Reset pot before posting blinds
            gameData.pot = 0;
            
            // Post blinds (for 2 players: player 0 is small blind/dealer, player 1 is big blind)
            const smallBlindPlayer = gameData.players[0];
            const bigBlindPlayer = gameData.players[1];
            
            console.log('Before posting blinds:');
            console.log('Small blind player chips:', smallBlindPlayer.chips);
            console.log('Big blind player chips:', bigBlindPlayer.chips);
            
            // Post small blind (all-in if necessary)
            const smallBlindAmount = Math.min(gameData.smallBlind, smallBlindPlayer.chips);
            smallBlindPlayer.chips -= smallBlindAmount;
            smallBlindPlayer.bet = smallBlindAmount;
            gameData.pot += smallBlindAmount;
            
            console.log('Posted small blind:', smallBlindAmount);
            console.log('Small blind player chips after:', smallBlindPlayer.chips);
            
            // Post big blind (all-in if necessary)
            const bigBlindAmount = Math.min(gameData.bigBlind, bigBlindPlayer.chips);
            bigBlindPlayer.chips -= bigBlindAmount;
            bigBlindPlayer.bet = bigBlindAmount;
            gameData.pot += bigBlindAmount;
            
            console.log('Posted big blind:', bigBlindAmount);
            console.log('Big blind player chips after:', bigBlindPlayer.chips);
            console.log('Total pot after blinds:', gameData.pot);
            
            // Set current bet to the highest bet (in case someone went all-in)
            gameData.currentBet = Math.max(smallBlindAmount, bigBlindAmount);
            
            // In heads-up (2 players), small blind acts first pre-flop
            gameData.currentPlayer = 0;
            gameData.playersActed = [];
            
            // If big blind is all-in with less than the full blind, small blind only needs to match
            if (bigBlindAmount < gameData.bigBlind && smallBlindAmount < bigBlindAmount) {
                gameData.currentBet = bigBlindAmount;
            }
        }

        function startGameListener(roomCode) {
            if (gameListener) {
                gameListener();
            }

            console.log('Starting game listener for room:', roomCode);
            
            gameListener = db.collection('games').doc(roomCode)
                .onSnapshot((doc) => {
                    if (doc.exists) {
                        const newGameData = doc.data();
                        const previousStage = currentGame ? currentGame.stage : null;
                        const previousHandCount = currentGame ? currentGame.handCount : 0;
                        
                        currentGame = newGameData;
                        currentGame.id = roomCode;
                        
                        // Log stage transitions
                        if (previousStage !== currentGame.stage) {
                            console.log('Game stage changed from', previousStage, 'to', currentGame.stage);
                        }
                        
                        // Check if a new hand started
                        if (previousHandCount && currentGame.handCount > previousHandCount) {
                            console.log('New hand started! Hand #', currentGame.handCount);
                            const gameTable = document.getElementById('gameTable');
                            gameTable.classList.add('new-hand');
                            setTimeout(() => {
                                gameTable.classList.remove('new-hand');
                            }, 1000);
                        }
                        
                        updateGameUI();
                    } else {
                        console.log('Game document does not exist');
                    }
                }, (error) => {
                    console.error('Error listening to game updates:', error);
                });
        }

        function showGame(roomCode) {
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            document.getElementById('roomCodeDisplay').textContent = `Room: ${roomCode}`;
            document.getElementById('gameUserName').textContent = playerName;
            document.getElementById('gameUserName').className = 'user-name' + (auth.currentUser && auth.currentUser.isAnonymous ? ' guest' : '');
            document.getElementById('gameUserAvatar').src = playerPhotoURL;
        }

        window.leaveGame = async function() {
            if (gameListener) {
                gameListener();
                gameListener = null;
            }
            if (chatListener) {
                chatListener();
                chatListener = null;
            }
            
            // Send leave message
            if (currentGame && currentGame.id) {
                await sendSystemMessage(currentGame.id, `${playerName} left the game`);
            }
            
            // Clean up any winner announcements
            const announcement = document.querySelector('.winner-announcement');
            if (announcement) {
                announcement.remove();
            }
            
            // Reset chat
            document.getElementById('chatMessages').innerHTML = '';
            unreadMessages = 0;
            updateChatBadge();
            
            // TODO: Optionally remove player from game in Firestore
            
            currentGame = null;
            document.getElementById('gameContainer').style.display = 'none';
            document.getElementById('lobby').style.display = 'flex';
            document.getElementById('joinGameSection').style.display = 'none';
            document.getElementById('roomCode').value = '';
        }

        function updateGameUI() {
            if (!currentGame) return;

            console.log('Updating UI - Current game state:', {
                stage: currentGame.stage,
                pot: currentGame.pot,
                currentPlayer: currentGame.currentPlayer,
                player0: currentGame.players[0] ? currentGame.players[0].name : 'none',
                player1: currentGame.players[1] ? currentGame.players[1].name : 'none'
            });

            // Update players
            currentGame.players.forEach((player, index) => {
                const playerSlot = document.getElementById(`player${index + 1}`);
                const isCurrentPlayer = index === currentGame.currentPlayer;
                const isMe = player.id === playerId;
                
                playerSlot.classList.toggle('current-player', isCurrentPlayer && currentGame.stage !== 'waiting' && currentGame.stage !== 'showdown');
                playerSlot.classList.toggle('active', isMe);
                playerSlot.style.opacity = player.folded ? '0.5' : '1';
                
                // Update position indicators (dealer/blinds)
                const positionEl = playerSlot.querySelector('.position-indicator');
                if (currentGame.stage !== 'waiting' && currentGame.players.length === 2) {
                    // In heads-up, player 0 is dealer/small blind, player 1 is big blind
                    if (index === 0) {
                        positionEl.style.display = 'flex';
                        positionEl.className = 'position-indicator dealer';
                        positionEl.innerHTML = 'D/SB';
                        positionEl.title = 'Dealer / Small Blind';
                    } else if (index === 1) {
                        positionEl.style.display = 'flex';
                        positionEl.className = 'position-indicator big-blind';
                        positionEl.innerHTML = 'BB';
                        positionEl.title = 'Big Blind';
                    }
                } else {
                    positionEl.style.display = 'none';
                }
                
                playerSlot.querySelector('.player-name').textContent = player.name + (isMe ? ' (You)' : '') + (player.folded ? ' (Folded)' : '');
                
                const chipsEl = playerSlot.querySelector('.player-chips');
                if (player.chips === 0) {
                    chipsEl.innerHTML = `<span class="chip-icon"></span> <span style="color: #e74c3c; font-weight: bold;">BANKRUPT</span>`;
                } else {
                    let chipDisplay = `<span class="chip-icon"></span> ${player.chips}`;
                    if (player.bet > 0) {
                        chipDisplay += ` <span style="color: #f39c12;">(Bet: ${player.bet})</span>`;
                    }
                    chipsEl.innerHTML = chipDisplay;
                }
                
                // Update hand rank display
                const handRankEl = playerSlot.querySelector('.player-hand-rank');
                if (player.cards && player.cards.length > 0 && !player.folded && player.chips > 0) {
                    // Show hand rank for yourself always, and for all players during showdown
                    if (isMe || currentGame.stage === 'showdown') {
                        let handEval;
                        
                        if (!currentGame.communityCards || currentGame.communityCards.length === 0) {
                            // Pre-flop: evaluate hole cards only
                            handEval = evaluateHoleCards(player.cards);
                        } else {
                            // Post-flop: evaluate best 5-card hand
                            const allCards = [...player.cards, ...currentGame.communityCards];
                            handEval = evaluateHand(allCards);
                        }
                        
                        handRankEl.textContent = handEval.name;
                        handRankEl.style.display = 'inline-block';
                        
                        // Add styling based on hand strength
                        handRankEl.className = 'player-hand-rank';
                        if (handEval.rank >= 6) {
                            handRankEl.classList.add('very-strong');
                        } else if (handEval.rank >= 3) {
                            handRankEl.classList.add('strong');
                        }
                    } else {
                        handRankEl.style.display = 'none';
                    }
                } else {
                    handRankEl.style.display = 'none';
                }
                
                const cardsContainer = playerSlot.querySelector('.player-cards');
                cardsContainer.innerHTML = '';
                
                if (player.cards && player.cards.length > 0) {
                    player.cards.forEach(card => {
                        const cardEl = document.createElement('div');
                        cardEl.className = `card ${isMe || currentGame.stage === 'showdown' ? suitColors[card.suit] : 'back'}`;
                        cardEl.textContent = isMe || currentGame.stage === 'showdown' ? `${card.rank}${card.suit}` : '';
                        cardsContainer.appendChild(cardEl);
                    });
                }
            });

            // Update pot
            document.getElementById('potAmount').textContent = currentGame.pot;
            
            // Update blinds info
            if (currentGame.smallBlind && currentGame.bigBlind) {
                document.getElementById('blindsInfo').textContent = `${currentGame.smallBlind}/${currentGame.bigBlind}`;
            }
            
            // Update hand count
            if (currentGame.handCount) {
                document.getElementById('handCount').textContent = currentGame.handCount;
            }

            // Update community cards
            const communityContainer = document.getElementById('communityCards');
            communityContainer.innerHTML = '';
            
            // Clear any leftover cards during waiting or new hand
            if (currentGame.stage === 'waiting' || 
                (currentGame.stage === 'preflop' && (!currentGame.communityCards || currentGame.communityCards.length === 0))) {
                communityContainer.innerHTML = '';
            } else if (currentGame.communityCards) {
                currentGame.communityCards.forEach(card => {
                    const cardEl = document.createElement('div');
                    cardEl.className = `card ${suitColors[card.suit]}`;
                    cardEl.textContent = `${card.rank}${card.suit}`;
                    communityContainer.appendChild(cardEl);
                });
            }

            // Update game status
            updateGameStatus();

            // Update action buttons
            updateActionButtons();
        }

        function updateGameStatus() {
            const statusEl = document.getElementById('gameStatus');
            
            if (currentGame.stage === 'waiting') {
                statusEl.textContent = 'Waiting for another player...';
            } else if (currentGame.stage === 'gameover') {
                statusEl.innerHTML = '<strong style="color: #e74c3c;">Game Over!</strong>';
            } else if (currentGame.stage === 'showdown') {
                // Show who won during showdown
                if (currentGame.lastWinner) {
                    statusEl.innerHTML = `<strong style="color: #f39c12;">${currentGame.lastWinner.name} wins ${currentGame.lastWinner.amount} chips with ${currentGame.lastWinner.hand}!</strong><br><small style="color: #ecf0f1;">Dealing new hand...</small>`;
                } else {
                    statusEl.textContent = 'Showdown!';
                }
            } else {
                const currentPlayer = currentGame.players[currentGame.currentPlayer];
                const isMyTurn = currentPlayer.id === playerId;
                
                // Vibrate on mobile when it's your turn (if supported)
                if (isMyTurn && isMobile && 'vibrate' in navigator && !statusEl.dataset.vibrated) {
                    navigator.vibrate(200);
                    statusEl.dataset.vibrated = 'true';
                } else if (!isMyTurn) {
                    delete statusEl.dataset.vibrated;
                }
                
                // Show current stage
                const stageNames = {
                    'preflop': 'Pre-Flop',
                    'flop': 'Flop',
                    'turn': 'Turn',
                    'river': 'River'
                };
                
                const stageName = stageNames[currentGame.stage] || currentGame.stage;
                
                // Check if blinds were just posted (pre-flop with pot > 0 and no community cards and no players have acted beyond blinds)
                if (currentGame.stage === 'preflop' && currentGame.pot > 0 && 
                    (!currentGame.communityCards || currentGame.communityCards.length === 0) &&
                    (!currentGame.playersActed || currentGame.playersActed.length === 0)) {
                    const blindsPosted = `<small style="color: #f39c12;">ðŸ’° Blinds posted: ${currentGame.smallBlind}/${currentGame.bigBlind}</small><br>`;
                    if (isMyTurn) {
                        statusEl.innerHTML = blindsPosted + `<strong>${stageName}</strong> - ${isMobile ? 'ðŸ‘† ' : ''}Your turn to act`;
                    } else {
                        statusEl.innerHTML = blindsPosted + `<strong>${stageName}</strong> - Waiting for ${currentPlayer.name}...`;
                    }
                } else {
                    if (isMyTurn) {
                        statusEl.innerHTML = `<strong>${stageName}</strong> - ${isMobile ? 'ðŸ‘† ' : ''}Your turn to act`;
                    } else {
                        statusEl.innerHTML = `<strong>${stageName}</strong> - Waiting for ${currentPlayer.name}...`;
                    }
                }
                
                // Show current bet if any
                if (currentGame.currentBet > 0) {
                    const myPlayer = currentGame.players.find(p => p.id === playerId);
                    const callAmount = currentGame.currentBet - (myPlayer ? myPlayer.bet : 0);
                    if (callAmount > 0) {
                        statusEl.innerHTML += ` (To call: ${callAmount})`;
                    }
                }
                
                // Show blind increase warning
                if (currentGame.handCount && currentGame.handCount % 5 === 4) {
                    statusEl.innerHTML += '<br><small style="color: #e74c3c;">âš ï¸ Blinds will increase next hand!</small>';
                } else if (currentGame.handCount && currentGame.handCount % 5 === 1 && currentGame.stage === 'preflop') {
                    statusEl.innerHTML += '<br><small style="color: #f39c12;">ðŸ“ˆ Blinds just increased!</small>';
                }
                
                // Show last winner info if this is a new hand (but not during the same hand)
                if (currentGame.lastWinner && currentGame.stage === 'preflop' && currentGame.pot > 0 && currentGame.pot <= (currentGame.smallBlind + currentGame.bigBlind)) {
                    statusEl.innerHTML = `<small style="color: #f39c12;">Last hand: ${currentGame.lastWinner.name} won ${currentGame.lastWinner.amount} chips</small><br>` + statusEl.innerHTML;
                }
            }
        }

        function updateActionButtons() {
            const actionButtons = document.getElementById('actionButtons');
            const betInput = document.getElementById('betInput');
            
            if (!currentGame || !currentGame.players) return;
            
            const currentPlayer = currentGame.players[currentGame.currentPlayer];
            const isMyTurn = currentPlayer && currentPlayer.id === playerId;
            const myPlayer = currentGame.players.find(p => p.id === playerId);
            
            // Check if we're in showdown and need to deal a new hand
            if (currentGame.stage === 'showdown' && currentGame.lastWinner) {
                // Show a "Deal New Hand" button as a fallback
                actionButtons.innerHTML = `
                    <button class="action-btn btn-primary" onclick="manuallyDealNewHand()">Deal New Hand</button>
                `;
                actionButtons.style.display = 'flex';
                betInput.style.display = 'none';
                return;
            }
            
            if (isMyTurn && currentGame.stage !== 'waiting' && currentGame.stage !== 'showdown' && currentGame.stage !== 'gameover' && !myPlayer.folded) {
                // Reset to default action buttons
                actionButtons.innerHTML = `
                    <button class="action-btn btn-fold" onclick="playerAction('fold')">Fold</button>
                    <button class="action-btn btn-check" onclick="playerAction('check')">Check</button>
                    <button class="action-btn btn-call" onclick="playerAction('call')">Call</button>
                    <button class="action-btn btn-raise" onclick="showRaiseInput()">Raise</button>
                `;
                actionButtons.style.display = 'flex';
                
                // Update button states
                const checkBtn = actionButtons.querySelector('.btn-check');
                const callBtn = actionButtons.querySelector('.btn-call');
                const raiseBtn = actionButtons.querySelector('.btn-raise');
                
                const callAmount = currentGame.currentBet - myPlayer.bet;
                
                if (callAmount === 0) {
                    checkBtn.style.display = 'block';
                    callBtn.style.display = 'none';
                } else {
                    checkBtn.style.display = 'none';
                    callBtn.style.display = 'block';
                    
                    // Handle all-in situations
                    if (callAmount >= myPlayer.chips) {
                        callBtn.textContent = `All-in ${myPlayer.chips}`;
                    } else {
                        callBtn.textContent = `Call ${callAmount}`;
                    }
                }
                
                // Disable raise if player doesn't have enough chips
                if (myPlayer.chips <= callAmount) {
                    raiseBtn.disabled = true;
                } else {
                    raiseBtn.disabled = false;
                }
            } else {
                actionButtons.style.display = 'none';
                betInput.style.display = 'none';
            }
        }

        window.showRaiseInput = function() {
            document.getElementById('betInput').style.display = 'flex';
            const myPlayer = currentGame.players.find(p => p.id === playerId);
            const callAmount = currentGame.currentBet - myPlayer.bet;
            
            // Minimum raise must be at least the size of the big blind or the last raise amount
            const minRaiseAmount = currentGame.bigBlind;
            const minRaise = callAmount + minRaiseAmount;
            const maxRaise = myPlayer.chips - callAmount;
            
            const raiseInput = document.getElementById('raiseAmount');
            raiseInput.min = minRaise;
            raiseInput.max = maxRaise;
            raiseInput.value = minRaise;
            raiseInput.placeholder = `Min: ${minRaise}, Max: ${maxRaise}`;
            
            // Auto-focus on mobile
            if (isMobile) {
                setTimeout(() => {
                    raiseInput.focus();
                    raiseInput.select();
                }, 100);
            }
        }

        window.playerAction = async function(action) {
            // Prevent actions during showdown or game over
            if (currentGame.stage === 'showdown' || currentGame.stage === 'gameover') {
                return;
            }
            
            const myPlayerIndex = currentGame.players.findIndex(p => p.id === playerId);
            const myPlayer = currentGame.players[myPlayerIndex];
            const gameRef = db.collection('games').doc(currentGame.id);
            
            try {
                const updates = {
                    players: currentGame.players,
                    pot: currentGame.pot,
                    currentBet: currentGame.currentBet,
                    currentPlayer: currentGame.currentPlayer,
                    stage: currentGame.stage,
                    communityCards: currentGame.communityCards,
                    deck: currentGame.deck,
                    playersActed: currentGame.playersActed || []
                };

                let actionMessage = '';

                switch (action) {
                    case 'fold':
                        myPlayer.folded = true;
                        actionMessage = `${playerName} folded`;
                        // When folding, we still count as having acted
                        if (!updates.playersActed.includes(myPlayerIndex)) {
                            updates.playersActed.push(myPlayerIndex);
                        }
                        break;
                        
                    case 'check':
                        actionMessage = `${playerName} checked`;
                        // No chips to add to pot
                        break;
                        
                    case 'call':
                        const callAmount = currentGame.currentBet - myPlayer.bet;
                        const actualCallAmount = Math.min(callAmount, myPlayer.chips);
                        
                        myPlayer.chips -= actualCallAmount;
                        myPlayer.bet += actualCallAmount;
                        updates.pot = (updates.pot || 0) + actualCallAmount;
                        
                        if (actualCallAmount >= myPlayer.chips) {
                            actionMessage = `${playerName} went all-in with ${actualCallAmount} chips`;
                        } else {
                            actionMessage = `${playerName} called ${actualCallAmount}`;
                        }
                        break;
                        
                    case 'raise':
                        const raiseAmount = parseInt(document.getElementById('raiseAmount').value);
                        if (isNaN(raiseAmount) || raiseAmount <= 0) {
                            alert('Please enter a valid raise amount');
                            return;
                        }
                        
                        const callCost = currentGame.currentBet - myPlayer.bet;
                        const totalCost = callCost + raiseAmount;
                        
                        if (totalCost <= myPlayer.chips) {
                            myPlayer.chips -= totalCost;
                            myPlayer.bet = currentGame.currentBet + raiseAmount;
                            updates.pot = (updates.pot || 0) + totalCost;
                            updates.currentBet = myPlayer.bet;
                            actionMessage = `${playerName} raised to ${updates.currentBet}`;
                            // When someone raises, only they have acted in this betting round
                            updates.playersActed = [myPlayerIndex];
                        } else {
                            alert('Insufficient chips for this raise');
                            return;
                        }
                        document.getElementById('betInput').style.display = 'none';
                        document.getElementById('raiseAmount').value = '';
                        break;
                }

                // Send action message to chat
                if (actionMessage) {
                    await sendSystemMessage(currentGame.id, actionMessage);
                }

                // Track that this player has acted (unless they raised, or already acted for fold)
                if (action !== 'raise' && action !== 'fold' && !updates.playersActed.includes(myPlayerIndex)) {
                    updates.playersActed.push(myPlayerIndex);
                }

                // Check if we need to advance to next stage
                if (shouldAdvanceStage(updates)) {
                    advanceStage(updates);
                } else {
                    // Move to next player
                    let nextPlayer = (updates.currentPlayer + 1) % updates.players.length;
                    
                    // Skip folded players
                    let attempts = 0;
                    while (updates.players[nextPlayer].folded && attempts < updates.players.length) {
                        nextPlayer = (nextPlayer + 1) % updates.players.length;
                        attempts++;
                    }
                    
                    // Safety check: if all players are folded except one (shouldn't happen but just in case)
                    if (attempts >= updates.players.length) {
                        advanceStage(updates);
                    } else {
                        updates.currentPlayer = nextPlayer;
                    }
                }

                await gameRef.update(updates);
            } catch (error) {
                console.error('Error performing action:', error);
                alert('Error performing action. Please try again.');
            }
        }

        function shouldAdvanceStage(gameData) {
            const activePlayers = gameData.players.filter(p => !p.folded);
            
            // If only one player left, they win
            if (activePlayers.length === 1) {
                return true;
            }
            
            // Initialize playersActed if it doesn't exist
            if (!gameData.playersActed) {
                gameData.playersActed = [];
            }
            
            // Check if all active players have matched the current bet
            const allMatched = activePlayers.every(p => p.bet === gameData.currentBet || p.chips === 0);
            
            // Count active players who need to act
            const activePlayerIndices = gameData.players
                .map((p, i) => ({ player: p, index: i }))
                .filter(({ player }) => !player.folded)
                .map(({ index }) => index);
            
            // Check if all active players have acted
            const allActivePlayersActed = activePlayerIndices.every(index => 
                gameData.playersActed.includes(index)
            );
            
            // Advance if all active players have acted and all bets are matched
            return allActivePlayersActed && allMatched;
        }

        async function advanceStage(gameData) {
            console.log('Advancing stage from:', gameData.stage);
            
            // Reset bets and players acted for new betting round
            gameData.players.forEach(p => p.bet = 0);
            gameData.currentBet = 0;
            gameData.playersActed = [];
            
            const activePlayers = gameData.players.filter(p => !p.folded);
            
            // If only one player remains, they win
            if (activePlayers.length === 1) {
                gameData.stage = 'showdown';
                await determineWinner(gameData);
                return;
            }
            
            // Set current player based on stage
            if (gameData.stage === 'preflop') {
                // Moving from preflop to flop - BB acts first (player 1 in heads-up)
                gameData.currentPlayer = 1;
            } else {
                // For all other streets, BB continues to act first
                gameData.currentPlayer = 1;
            }
            
            // Skip to active player if current player has folded
            let attempts = 0;
            while (gameData.players[gameData.currentPlayer].folded && attempts < gameData.players.length) {
                gameData.currentPlayer = (gameData.currentPlayer + 1) % gameData.players.length;
                attempts++;
            }
            
            let stageMessage = '';
            
            switch (gameData.stage) {
                case 'preflop':
                    gameData.stage = 'flop';
                    // Deal 3 community cards
                    for (let i = 0; i < 3; i++) {
                        gameData.communityCards.push(gameData.deck.pop());
                    }
                    stageMessage = 'ðŸƒ Dealing the flop...';
                    console.log('Dealt flop:', gameData.communityCards.slice(0, 3));
                    break;
                    
                case 'flop':
                    gameData.stage = 'turn';
                    // Deal 1 card
                    gameData.communityCards.push(gameData.deck.pop());
                    stageMessage = 'ðŸƒ Dealing the turn...';
                    console.log('Dealt turn:', gameData.communityCards[3]);
                    break;
                    
                case 'turn':
                    gameData.stage = 'river';
                    // Deal 1 card
                    gameData.communityCards.push(gameData.deck.pop());
                    stageMessage = 'ðŸƒ Dealing the river...';
                    console.log('Dealt river:', gameData.communityCards[4]);
                    break;
                    
                case 'river':
                    gameData.stage = 'showdown';
                    stageMessage = 'ðŸŽ¯ Showdown!';
                    await determineWinner(gameData);
                    break;
            }
            
            // Send stage message to chat
            if (stageMessage && currentGame && currentGame.id) {
                await sendSystemMessage(currentGame.id, stageMessage);
            }
            
            console.log('Advanced to stage:', gameData.stage, 'Current player:', gameData.currentPlayer);
        }

        async function determineWinner(gameData) {
            const activePlayers = gameData.players.filter(p => !p.folded);
            
            if (activePlayers.length === 1) {
                // Winner by default (everyone else folded)
                const winner = activePlayers[0];
                winner.chips += gameData.pot;
                
                // Update game status
                gameData.lastWinner = {
                    name: winner.name,
                    amount: gameData.pot,
                    hand: 'Everyone folded'
                };
                
                // Send winner message
                if (currentGame && currentGame.id) {
                    await sendSystemMessage(currentGame.id, `ðŸ† ${winner.name} wins ${gameData.pot} chips (everyone folded)`);
                }
                
                // Check for bankruptcy
                await checkForBankruptcy(gameData);
            } else {
                // Evaluate hands
                const playerHands = activePlayers.map(player => ({
                    player,
                    hand: evaluateHand([...player.cards, ...gameData.communityCards])
                }));
                
                // Sort by hand rank
                playerHands.sort((a, b) => compareHands(b.hand, a.hand));
                
                const winner = playerHands[0].player;
                
                // Give pot to winner
                winner.chips += gameData.pot;
                
                // Update game status to show who won
                gameData.lastWinner = {
                    name: winner.name,
                    amount: gameData.pot,
                    hand: playerHands[0].hand.name
                };
                
                // Send winner message
                if (currentGame && currentGame.id) {
                    await sendSystemMessage(currentGame.id, `ðŸ† ${winner.name} wins ${gameData.pot} chips with ${playerHands[0].hand.name}`);
                }
                
                // Check for bankruptcy
                await checkForBankruptcy(gameData);
            }
        }
        
        async function checkForBankruptcy(gameData) {
            const bankruptPlayer = gameData.players.find(p => p.chips === 0);
            
            if (bankruptPlayer) {
                // Someone is bankrupt - show final winner
                const winner = gameData.players.find(p => p.chips > 0);
                
                // Send game over message
                if (currentGame && currentGame.id) {
                    await sendSystemMessage(currentGame.id, `ðŸ’¥ GAME OVER! ${winner.name} wins! ${bankruptPlayer.name} went bankrupt!`);
                }
                
                // Update Firestore first
                const gameRef = db.collection('games').doc(currentGame.id);
                await gameRef.update({
                    players: gameData.players,
                    stage: 'gameover',
                    lastWinner: gameData.lastWinner,
                    pot: gameData.pot
                });
                
                // Then show the winner popup
                showFinalWinner(winner, bankruptPlayer);
            } else {
                // No one bankrupt - show winner briefly then start new hand
                console.log('Hand complete - Winner:', gameData.lastWinner.name, 'won', gameData.lastWinner.amount);
                
                // First update to showdown to display the winner
                const gameRef = db.collection('games').doc(currentGame.id);
                await gameRef.update({
                    players: gameData.players,
                    stage: 'showdown',
                    lastWinner: gameData.lastWinner,
                    pot: gameData.pot
                });
                
                // Wait a brief moment to show the winner, then start new hand
                setTimeout(async () => {
                    console.log('Starting new hand...');
                    
                    // Get fresh game data to avoid conflicts
                    const gameDoc = await gameRef.get();
                    const freshGameData = gameDoc.data();
                    
                    // Reset the game state for new hand
                    resetGame(freshGameData);
                    
                    // Send new hand message
                    if (currentGame && currentGame.id) {
                        await sendSystemMessage(currentGame.id, `ðŸŽ² Starting hand #${freshGameData.handCount}! Blinds: ${freshGameData.smallBlind}/${freshGameData.bigBlind}`);
                    }
                    
                    console.log('After resetGame and dealCards for new hand:');
                    console.log('Player 0:', freshGameData.players[0].name, 'Chips:', freshGameData.players[0].chips, 'Bet:', freshGameData.players[0].bet);
                    console.log('Player 1:', freshGameData.players[1].name, 'Chips:', freshGameData.players[1].chips, 'Bet:', freshGameData.players[1].bet);
                    console.log('Pot:', freshGameData.pot, 'Current Bet:', freshGameData.currentBet);
                    console.log('Stage:', freshGameData.stage, 'Current Player:', freshGameData.currentPlayer);
                    
                    // Update Firestore with the new game state
                    await gameRef.update({
                        players: freshGameData.players,
                        deck: freshGameData.deck,
                        communityCards: freshGameData.communityCards,
                        pot: freshGameData.pot,
                        currentBet: freshGameData.currentBet,
                        currentPlayer: freshGameData.currentPlayer,
                        stage: freshGameData.stage,
                        playersActed: freshGameData.playersActed,
                        handCount: freshGameData.handCount,
                        smallBlind: freshGameData.smallBlind,
                        bigBlind: freshGameData.bigBlind,
                        lastWinner: freshGameData.lastWinner
                    });
                    
                    console.log('Firestore updated with new hand data');
                }, 1500); // 1.5 second delay to show winner
            }
        }
        
        function showFinalWinner(winner, loser) {
            const announcement = document.createElement('div');
            announcement.className = 'winner-announcement';
            announcement.innerHTML = `
                <h2>ðŸ† Game Over! ðŸ†</h2>
                <p style="font-size: 2rem; color: #f39c12; margin: 20px 0;">${winner.name} Wins!</p>
                <p>${loser.name} has gone bankrupt</p>
                <p style="margin-top: 10px; font-size: 0.9rem; color: rgba(255, 255, 255, 0.7);">
                    Game ended at blinds ${currentGame.smallBlind}/${currentGame.bigBlind}
                </p>
                <p style="margin-top: 20px;">Final chip count: <strong>${winner.chips}</strong></p>
                <button class="btn btn-primary" onclick="startNewMatch()">New Game</button>
                <button class="btn btn-secondary" onclick="returnToLobby()">Return to Lobby</button>
            `;
            document.body.appendChild(announcement);
        }
        
        window.startNewMatch = async function() {
            // Close the announcement
            const announcement = document.querySelector('.winner-announcement');
            if (announcement) {
                announcement.remove();
            }
            
            // Reset both players to starting chips
            if (currentGame && currentGame.players) {
                currentGame.players.forEach(player => {
                    player.chips = 5000;
                    player.cards = [];
                    player.bet = 0;
                    player.folded = false;
                });
                
                // Reset blinds and hand count
                currentGame.smallBlind = 25;
                currentGame.bigBlind = 50;
                currentGame.handCount = 0;
                currentGame.pot = 0;
                currentGame.currentBet = 0;
                currentGame.playersActed = [];
                
                // Clear the last winner and reset stage
                currentGame.lastWinner = null;
                currentGame.stage = 'preflop';
                
                // Create new deck
                currentGame.deck = createDeck();
                currentGame.communityCards = [];
                currentGame.currentPlayer = 0;
                
                // Deal cards and post blinds for the new game
                dealCards(currentGame);
                
                // Send new game message
                await sendSystemMessage(currentGame.id, 'ðŸŽ® New game started! Each player has 5000 chips.');
                
                console.log('Starting new match after bankruptcy:');
                console.log('Player 0:', currentGame.players[0].name, 'Chips:', currentGame.players[0].chips, 'Bet:', currentGame.players[0].bet);
                console.log('Player 1:', currentGame.players[1].name, 'Chips:', currentGame.players[1].chips, 'Bet:', currentGame.players[1].bet);
                console.log('Pot:', currentGame.pot, 'Current Bet:', currentGame.currentBet);
                
                // Update the game in Firestore with all fields
                const gameRef = db.collection('games').doc(currentGame.id);
                gameRef.update({
                    players: currentGame.players,
                    deck: currentGame.deck,
                    communityCards: currentGame.communityCards,
                    pot: currentGame.pot,
                    currentBet: currentGame.currentBet,
                    currentPlayer: currentGame.currentPlayer,
                    stage: currentGame.stage,
                    playersActed: currentGame.playersActed,
                    handCount: currentGame.handCount,
                    smallBlind: currentGame.smallBlind,
                    bigBlind: currentGame.bigBlind,
                    lastWinner: currentGame.lastWinner
                });
            }
        }
        
        window.returnToLobby = function() {
            // Close the announcement
            const announcement = document.querySelector('.winner-announcement');
            if (announcement) {
                announcement.remove();
            }
            
            // Leave the game
            leaveGame();
        }

        function evaluateHoleCards(cards) {
            if (cards.length !== 2) return { rank: 0, name: 'Invalid' };
            
            const rank1 = getRankValue(cards[0].rank);
            const rank2 = getRankValue(cards[1].rank);
            const suited = cards[0].suit === cards[1].suit;
            
            const highRank = Math.max(rank1, rank2);
            const lowRank = Math.min(rank1, rank2);
            
            // Pocket pair
            if (rank1 === rank2) {
                const rankNames = { 
                    14: 'Aces', 13: 'Kings', 12: 'Queens', 11: 'Jacks',
                    10: 'Tens', 9: 'Nines', 8: 'Eights', 7: 'Sevens',
                    6: 'Sixes', 5: 'Fives', 4: 'Fours', 3: 'Threes', 2: 'Twos'
                };
                const pairName = rankNames[rank1] || `${cards[0].rank}s`;
                return { rank: 1, name: `Pocket ${pairName}` };
            }
            
            // High cards
            const cardNames = { 14: 'Ace', 13: 'King', 12: 'Queen', 11: 'Jack', 10: 'Ten' };
            const highCardName = cardNames[highRank] || highRank;
            const lowCardName = cardNames[lowRank] || lowRank;
            
            // Special combinations
            if (highRank === 14 && lowRank === 13) {
                return { rank: 0.9, name: suited ? 'Big Slick (suited)' : 'Big Slick' };
            }
            
            // Connected cards
            const gap = highRank - lowRank;
            if (gap === 1) {
                return { rank: 0.5, name: `${highCardName}-${lowCardName} ${suited ? 'suited' : 'connectors'}` };
            }
            
            // Suited cards
            if (suited) {
                return { rank: 0.3, name: `${highCardName}-${lowCardName} suited` };
            }
            
            // Default
            return { rank: 0, name: `${highCardName}-${lowCardName}` };
        }

        function evaluateHand(cards) {
            if (cards.length < 5) return { rank: 0, name: 'Incomplete' };
            
            // Get all possible 5-card combinations
            const combinations = getCombinations(cards, 5);
            let bestHand = { rank: -1, name: 'High Card' };
            
            // Evaluate each combination
            for (const combo of combinations) {
                const hand = evaluateFiveCards(combo);
                if (hand.rank > bestHand.rank) {
                    bestHand = hand;
                }
            }
            
            return bestHand;
        }
        
        function getCombinations(arr, size) {
            const combinations = [];
            
            function combine(start, combo) {
                if (combo.length === size) {
                    combinations.push([...combo]);
                    return;
                }
                
                for (let i = start; i < arr.length; i++) {
                    combo.push(arr[i]);
                    combine(i + 1, combo);
                    combo.pop();
                }
            }
            
            combine(0, []);
            return combinations;
        }
        
        function evaluateFiveCards(cards) {
            const ranks = cards.map(c => getRankValue(c.rank));
            const suits = cards.map(c => c.suit);
            
            // Sort ranks in descending order
            ranks.sort((a, b) => b - a);
            
            // Count occurrences
            const rankCounts = {};
            ranks.forEach(rank => {
                rankCounts[rank] = (rankCounts[rank] || 0) + 1;
            });
            
            const counts = Object.values(rankCounts).sort((a, b) => b - a);
            const uniqueRanks = Object.keys(rankCounts).map(Number).sort((a, b) => b - a);
            
            // Check for flush
            const suitCounts = {};
            suits.forEach(suit => {
                suitCounts[suit] = (suitCounts[suit] || 0) + 1;
            });
            const isFlush = Object.values(suitCounts).some(count => count === 5);
            
            // Check for straight
            const isStraight = checkFiveStraight(uniqueRanks);
            const isWheel = uniqueRanks.length === 5 && 
                          uniqueRanks[0] === 14 && uniqueRanks[1] === 5 && 
                          uniqueRanks[2] === 4 && uniqueRanks[3] === 3 && uniqueRanks[4] === 2;
            
            // Determine hand rank
            if ((isStraight || isWheel) && isFlush) {
                if (isStraight && uniqueRanks[0] === 14 && uniqueRanks[1] === 13) {
                    return { rank: 9, name: 'Royal Flush' };
                }
                return { rank: 8, name: 'Straight Flush' };
            }
            
            // Get card names for better display
            const cardNames = { 14: 'Aces', 13: 'Kings', 12: 'Queens', 11: 'Jacks', 10: 'Tens',
                               9: 'Nines', 8: 'Eights', 7: 'Sevens', 6: 'Sixes', 5: 'Fives',
                               4: 'Fours', 3: 'Threes', 2: 'Twos' };
            
            if (counts[0] === 4) {
                const quadRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 4));
                const quadName = cardNames[quadRank] || `${quadRank}s`;
                return { rank: 7, name: `Four ${quadName}` };
            }
            
            if (counts[0] === 3 && counts[1] === 2) {
                const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3));
                const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2));
                const tripName = cardNames[tripRank] || `${tripRank}s`;
                const pairName = cardNames[pairRank] || `${pairRank}s`;
                return { rank: 6, name: `Full House` };
            }
            
            if (isFlush) return { rank: 5, name: 'Flush' };
            if (isStraight || isWheel) return { rank: 4, name: 'Straight' };
            
            if (counts[0] === 3) {
                const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3));
                const tripName = cardNames[tripRank] || `${tripRank}s`;
                return { rank: 3, name: `Three ${tripName}` };
            }
            
            if (counts[0] === 2 && counts[1] === 2) {
                return { rank: 2, name: `Two Pair` };
            }
            
            if (counts[0] === 2) {
                const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2));
                const pairName = cardNames[pairRank] || `${pairRank}s`;
                return { rank: 1, name: `Pair of ${pairName}` };
            }
            
            // High card - include the high card value
            const highCard = ranks[0];
            const highCardNames = { 14: 'Ace', 13: 'King', 12: 'Queen', 11: 'Jack', 10: 'Ten' };
            const highCardName = highCardNames[highCard] || highCard;
            return { rank: 0, name: `${highCardName} High` };
        }
        
        function checkFiveStraight(uniqueRanks) {
            if (uniqueRanks.length !== 5) return false;
            
            for (let i = 0; i < 4; i++) {
                if (uniqueRanks[i] - uniqueRanks[i + 1] !== 1) {
                    return false;
                }
            }
            return true;
        }

        function getRankValue(rank) {
            const values = { 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
            return values[rank] || parseInt(rank);
        }

        function compareHands(a, b) {
            if (a.rank !== b.rank) return a.rank - b.rank;
            if (a.highCard && b.highCard) return a.highCard - b.highCard;
            return 0;
        }

        function showWinner(winner, pot, hand) {
            const announcement = document.createElement('div');
            announcement.className = 'winner-announcement';
            announcement.innerHTML = `
                <h2>ðŸŽ‰ Winner! ðŸŽ‰</h2>
                <p>${winner.name} wins ${pot} chips!</p>
                ${hand ? `<p style="color: #f39c12; font-size: 1.3rem;">With: ${hand.name}</p>` : ''}
                <button class="btn btn-primary" onclick="closeWinnerAnnouncement()">Continue</button>
            `;
            document.body.appendChild(announcement);
        }

        function closeWinnerAnnouncement() {
            const announcement = document.querySelector('.winner-announcement');
            if (announcement) {
                announcement.remove();
            }
        }

        function resetGame(gameData) {
            console.log('=== RESETTING GAME FOR NEW HAND ===');
            console.log('Before rotation - Player 0:', gameData.players[0].name, 'Player 1:', gameData.players[1].name);
            
            // Rotate dealer position (swap players for heads-up)
            if (gameData.players.length === 2) {
                // Swap player positions to rotate dealer/blinds
                [gameData.players[0], gameData.players[1]] = [gameData.players[1], gameData.players[0]];
                console.log('After rotation - Player 0 (new SB/Dealer):', gameData.players[0].name, 'Player 1 (new BB):', gameData.players[1].name);
            }
            
            // Reset for next hand
            gameData.deck = createDeck();
            gameData.communityCards = [];
            gameData.pot = 0;
            gameData.currentBet = 0;
            gameData.currentPlayer = 0;
            gameData.stage = 'preflop';
            gameData.playersActed = [];
            
            gameData.players.forEach(player => {
                player.cards = [];
                player.bet = 0;
                player.folded = false;
            });
            
            // Only deal if no one is bankrupt
            const bankruptPlayer = gameData.players.find(p => p.chips === 0);
            if (!bankruptPlayer) {
                try {
                    dealCards(gameData);
                    console.log('New hand dealt successfully - Pot after blinds:', gameData.pot);
                } catch (error) {
                    console.error('Error dealing cards:', error);
                }
            }
        }
        
        async function manuallyDealNewHand() {
            if (!currentGame || currentGame.stage !== 'showdown') return;
            
            console.log('Manually dealing new hand...');
            
            try {
                const gameRef = db.collection('games').doc(currentGame.id);
                const gameDoc = await gameRef.get();
                const gameData = gameDoc.data();
                
                // Reset the game state for new hand
                resetGame(gameData);
                
                // Send new hand message
                await sendSystemMessage(currentGame.id, `ðŸŽ² Starting hand #${gameData.handCount}! Blinds: ${gameData.smallBlind}/${gameData.bigBlind}`);
                
                // Update Firestore with the new game state
                await gameRef.update({
                    players: gameData.players,
                    deck: gameData.deck,
                    communityCards: gameData.communityCards,
                    pot: gameData.pot,
                    currentBet: gameData.currentBet,
                    currentPlayer: gameData.currentPlayer,
                    stage: gameData.stage,
                    playersActed: gameData.playersActed,
                    handCount: gameData.handCount,
                    smallBlind: gameData.smallBlind,
                    bigBlind: gameData.bigBlind,
                    lastWinner: gameData.lastWinner
                });
                
                console.log('New hand dealt manually');
            } catch (error) {
                console.error('Error dealing new hand:', error);
                alert('Error dealing new hand. Please try again.');
            }
        }

        // Chat functionality
        function startChatListener(roomCode) {
            if (chatListener) {
                chatListener();
            }

            console.log('Starting chat listener for room:', roomCode);
            
            chatListener = db.collection('games').doc(roomCode).collection('messages')
                .orderBy('timestamp', 'asc')
                .onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const message = change.doc.data();
                            displayMessage(message);
                            
                            // Update unread count if chat is hidden and message is not from current user
                            if (isMobile && !document.getElementById('chatContainer').classList.contains('mobile-visible') && 
                                message.userId !== playerId) {
                                unreadMessages++;
                                updateChatBadge();
                            }
                        }
                    });
                }, (error) => {
                    console.error('Error listening to chat updates:', error);
                });
        }

        function displayMessage(message) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageEl = document.createElement('div');
            
            const isOwn = message.userId === playerId;
            const isSystem = message.type === 'system';
            
            messageEl.className = `chat-message ${isOwn ? 'own' : ''} ${isSystem ? 'system' : ''}`;
            
            if (isSystem) {
                messageEl.innerHTML = `
                    <div class="message-content">
                        <div class="message-text">${message.text}</div>
                        <div class="message-time">${formatTime(message.timestamp)}</div>
                    </div>
                `;
            } else {
                messageEl.innerHTML = `
                    ${!isOwn ? `<img class="message-avatar" src="${message.userAvatar}" onerror="this.src='https://www.gravatar.com/avatar/?d=mp&s=200'">` : ''}
                    <div class="message-content">
                        <div class="message-author">${message.userName}</div>
                        <div class="message-text">${message.text}</div>
                        <div class="message-time">${formatTime(message.timestamp)}</div>
                    </div>
                    ${isOwn ? `<img class="message-avatar" src="${message.userAvatar}" onerror="this.src='https://www.gravatar.com/avatar/?d=mp&s=200'">` : ''}
                `;
            }
            
            messagesContainer.appendChild(messageEl);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function formatTime(timestamp) {
            if (!timestamp) return '';
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const text = input.value.trim();
            
            if (!text || !currentGame || !currentGame.id) return;
            
            try {
                await db.collection('games').doc(currentGame.id).collection('messages').add({
                    text: text,
                    userId: playerId,
                    userName: playerName,
                    userAvatar: playerPhotoURL,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    type: 'user'
                });
                
                input.value = '';
            } catch (error) {
                console.error('Error sending message:', error);
            }
        }

        async function sendSystemMessage(roomCode, text) {
            if (!roomCode) return;
            
            try {
                await db.collection('games').doc(roomCode).collection('messages').add({
                    text: text,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    type: 'system'
                });
            } catch (error) {
                console.error('Error sending system message:', error);
            }
        }

        function toggleMobileChat() {
            const chatContainer = document.getElementById('chatContainer');
            const isVisible = chatContainer.classList.contains('mobile-visible');
            
            if (isVisible) {
                chatContainer.classList.remove('mobile-visible');
            } else {
                chatContainer.classList.add('mobile-visible');
                // Reset unread count
                unreadMessages = 0;
                updateChatBadge();
                // Focus input
                setTimeout(() => {
                    document.getElementById('chatInput').focus();
                }, 100);
            }
        }

        function updateChatBadge() {
            const badge = document.getElementById('chatBadge');
            if (unreadMessages > 0) {
                badge.textContent = unreadMessages > 9 ? '9+' : unreadMessages;
                badge.style.display = 'flex';
            } else {
                badge.style.display = 'none';
            }
        }

        // Chat input handling
        document.addEventListener('DOMContentLoaded', () => {
            const chatInput = document.getElementById('chatInput');
            const chatSendBtn = document.getElementById('chatSendBtn');
            
            // Send message on Enter
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
            
            // Update send button state
            chatInput.addEventListener('input', () => {
                chatSendBtn.disabled = !chatInput.value.trim();
            });
        });